## Part 1: The Default Strategy (CheckAlways) - Foundation & View Checking

### Slide: Angular Change Detection: A Deep Dive
#### Subtitle: From Default Strategy to Signals - Complete Guide
This comprehensive presentation will guide you through the evolution and mechanics of change detection in Angular. We'll explore how Angular knows when your data changes and how it efficiently updates the user interface.

**What we'll cover in this deep dive:**
- Part 1: The Default Strategy (CheckAlways) - Foundation & View Checking
- Part 2: The Trigger (Zone.js) - Automation & Monkey Patching
- Part 3: The Optimization (OnPush) - Performance & Immutability
- Part 4: The Revolution (Signals) - Fine-grained Reactivity
- Part 5: The Future (Zoneless) - Modern Angular Architecture

**Problem:** Teams often struggle with Angular performance issues without understanding the underlying change detection mechanisms, leading to inefficient applications and frustrated developers.
**Solution:** A comprehensive understanding of change detection evolution provides the knowledge needed to build performant, maintainable Angular applications.
**Benefits:**
- Deep understanding of Angular internals
- Ability to diagnose performance issues
- Knowledge of modern optimization techniques
- Future-ready development skills

---

### Slide: Part 1: The Default Strategy (CheckAlways)
#### Subtitle: The Foundation of Angular Change Detection
The default strategy is the foundational change detection mechanism in Angular. It's reliable, easy to understand, and the default behavior for all components.

**Highlight:** Every Angular application is a tree of components. Change detection always starts at the root component and proceeds downwards to its children, one by one. This is unidirectional data flow.

**Key characteristics of the default strategy:**
- Top-down view checking from root to leaves
- Predictable unidirectional data flow
- Checks every component on every cycle
- Compares current vs previous values
- Updates DOM only when changes detected
- Simple but potentially inefficient at scale

**Code Example: Default Strategy in Action**
```typescript
@Component({
  selector: 'app-root',
  // Default strategy is implicit (ChangeDetectionStrategy.Default)
  template: `
    <div class="app">
      <h1>{{ title }}</h1>
      <app-header [user]="currentUser"></app-header>
      <app-main [data]="mainData"></app-main>
      <app-footer [stats]="footerStats"></app-footer>
    </div>
  `
})
export class AppComponent {
  title = 'My Angular App';
  currentUser = { name: 'John', role: 'admin' };
  mainData = { items: [], loading: false };
  footerStats = { visits: 1000, users: 50 };
  
  // Any change here triggers checking of ENTIRE tree
  updateUser() {
    this.currentUser = { ...this.currentUser, name: 'Jane' };
    // Angular will check AppComponent, HeaderComponent, MainComponent, FooterComponent
    // Even though only HeaderComponent actually needs to update!
  }
}

@Component({
  selector: 'app-header',
  template: `
    <header>
      <span>Welcome {{ user.name }}!</span>
      <span>Role: {{ user.role }}</span>
      <!-- These expressions are checked EVERY cycle -->
      <span>Time: {{ getCurrentTime() }}</span>
    </header>
  `
})
export class HeaderComponent {
  @Input() user!: User;
  
  getCurrentTime() {
    console.log('getCurrentTime called!'); // This logs on EVERY change detection!
    return new Date().toLocaleTimeString();
  }
}
```
**Explanation:** With default strategy, every component is checked on every change detection cycle. Even unrelated changes trigger checks across the entire component tree.

**Problem:** The default strategy checks every component on every change detection cycle, which can lead to performance issues in large applications with complex component trees.
**Solution:** Understanding how the default strategy works helps developers identify performance bottlenecks and make informed decisions about optimization strategies.
**Benefits:**
- Guaranteed UI consistency
- Simple mental model
- No configuration required
- Works with any coding pattern
**Implementation:** Angular traverses the component tree from root to leaves, checking all bindings and executing all template expressions in every component.

---

### Slide: View Checking Internals: LView & TView
#### Subtitle: How Angular Tracks and Compares Values
Internally, Angular creates sophisticated data structures to efficiently track component state and detect changes. Understanding these internals helps explain why certain patterns are more performant.

**Angular's internal view structures:**
- LView (Logical View) - Runtime instance data for each component
- TView (Template View) - Static template structure and metadata
- Binding records - Track previous values for comparison
- Node references - Direct DOM element pointers
- Change detection flags - Control when checks occur
- Dirty checking - currentValue !== previousValue comparison

**Highlight:** Angular uses strict equality (===) for change detection. This is why immutable patterns are crucial for performance optimization.

**Code Example: Understanding View Checking Process**
```typescript
// Simplified representation of Angular's internal process
interface LView {
  // Component instance data
  component: any;
  // DOM node references
  nodes: Node[];
  // Previous binding values for comparison
  bindingValues: any[];
  // Flags controlling change detection
  flags: LViewFlags;
}

interface TView {
  // Template structure
  template: string;
  // Binding definitions
  bindings: BindingDef[];
  // Child component definitions
  children: ComponentDef[];
}

// Simplified change detection process
function checkView(lView: LView, tView: TView) {
  const component = lView.component;
  
  // Check each binding in the template
  for (let i = 0; i < tView.bindings.length; i++) {
    const binding = tView.bindings[i];
    const currentValue = evaluateBinding(binding, component);
    const previousValue = lView.bindingValues[i];
    
    // Strict equality check - this is why immutability matters!
    if (currentValue !== previousValue) {
      // Update DOM
      updateDOM(lView.nodes[binding.nodeIndex], currentValue);
      // Store new value for next comparison
      lView.bindingValues[i] = currentValue;
    }
  }
  
  // Recursively check child components
  for (const child of getChildViews(lView)) {
    checkView(child.lView, child.tView);
  }
}

// Example of why object mutations don't trigger updates
const user = { name: 'John', age: 30 };
user.name = 'Jane'; // Same object reference!
// currentValue === previousValue (both point to same object)
// No DOM update occurs!

// Immutable update creates new reference
const updatedUser = { ...user, name: 'Jane' };
// currentValue !== previousValue (different object references)
// DOM update occurs!
```
**Explanation:** Angular's change detection relies on reference equality checks. Understanding this internal mechanism explains why immutable patterns are essential for reliable change detection.

**Problem:** Developers often encounter mysterious change detection issues because they don't understand Angular's internal comparison mechanisms.
**Solution:** Understanding LView, TView, and reference-based change detection helps developers write code that works predictably with Angular's internals.
**Benefits:**
- Predictable change detection behavior
- Better debugging capabilities
- Understanding of performance implications
- Knowledge of why immutability matters
**Implementation:** Use immutable update patterns and avoid direct object mutations to ensure Angular's reference-based change detection works correctly.

---

### Slide: Unidirectional Data Flow
#### Subtitle: Predictability Through Strict Flow Control
Angular enforces unidirectional data flow to prevent the infinite loops and unpredictable behavior that plagued AngularJS. Data flows down from parent to child via @Input() bindings.

**Comparison: AngularJS vs Angular Data Flow:**
- **Before:** AngularJS: Bidirectional binding could cause infinite digest loops and unpredictable updates
- **After:** Angular: Strict unidirectional flow prevents infinite loops and makes behavior predictable

**Benefits of unidirectional data flow:**
- Prevents infinite change detection loops
- Makes data flow predictable and traceable
- Easier debugging and testing
- Better performance characteristics
- Clearer component relationships
- Enables better optimization strategies

**Code Example: Unidirectional Data Flow Example**
```typescript
// Parent Component
@Component({
  selector: 'app-parent',
  template: `
    <div>
      <h2>Parent: {{ parentData.count }}</h2>
      <!-- Data flows DOWN to child via @Input -->
      <app-child 
        [childData]="parentData"
        (dataChange)="onChildDataChange($event)">
      </app-child>
      <button (click)="incrementParent()">Increment Parent</button>
    </div>
  `
})
export class ParentComponent {
  parentData = { count: 0, message: 'Hello' };
  
  incrementParent() {
    // ✅ Immutable update - creates new reference
    this.parentData = {
      ...this.parentData,
      count: this.parentData.count + 1
    };
  }
  
  onChildDataChange(newData: any) {
    // Events flow UP from child to parent
    this.parentData = newData;
  }
}

// Child Component
@Component({
  selector: 'app-child',
  template: `
    <div>
      <h3>Child: {{ childData.count }}</h3>
      <p>{{ childData.message }}</p>
      <!-- Child can emit events UP to parent -->
      <button (click)="incrementChild()">Increment Child</button>
    </div>
  `
})
export class ChildComponent {
  @Input() childData!: { count: number; message: string };
  @Output() dataChange = new EventEmitter<any>();
  
  incrementChild() {
    // ❌ DON'T mutate input directly - breaks unidirectional flow
    // this.childData.count++; 
    
    // ✅ Emit event to parent - maintains unidirectional flow
    const newData = {
      ...this.childData,
      count: this.childData.count + 1
    };
    this.dataChange.emit(newData);
  }
}

// Angular's Change Detection Cycle
// 1. Start at root component
// 2. Check parent component bindings
// 3. Pass data DOWN to child via @Input
// 4. Check child component bindings
// 5. If child emits event, handle in parent
// 6. If parent data changes, start new cycle
// 7. Never allow child to directly modify parent during same cycle
```
**Explanation:** Unidirectional data flow ensures predictable behavior by enforcing that data flows down through @Input and events flow up through @Output, preventing circular dependencies.

**Problem:** Bidirectional data binding in AngularJS could cause infinite digest loops and unpredictable application behavior.
**Solution:** Angular's unidirectional data flow enforces a strict parent-to-child data flow pattern with event-based communication back up.
**Benefits:**
- Eliminates infinite loops
- Predictable data flow
- Easier debugging
- Better performance
- Clearer architecture
**Implementation:** Always pass data down via @Input and communicate up via @Output events. Never mutate input properties directly.

---

### Slide: Performance Implications at Scale
#### Subtitle: When Default Strategy Becomes a Bottleneck
While the default strategy is simple and reliable, it has significant performance implications in large applications. Understanding these limitations is crucial for building scalable Angular applications.

**Performance challenges with default strategy:**
- O(n) complexity - checks grow linearly with component count
- Unnecessary checks - components that haven't changed are still checked
- Function calls in templates execute on every cycle
- Deep object comparisons can be expensive
- Large component trees create significant overhead
- Frequent Zone.js triggers compound the problem

**Highlight:** In a large application with 1000+ components, a single button click can trigger thousands of unnecessary binding checks, even if only one component actually needs to update.

**Code Example: Performance Anti-patterns with Default Strategy**
```typescript
// ❌ Performance Anti-patterns
@Component({
  template: `
    <div>
      <!-- Function calls in templates - AVOID! -->
      <h1>{{ getTitle() }}</h1>
      <p>Items: {{ getItemCount() }}</p>
      <p>Status: {{ getComplexStatus() }}</p>
      
      <!-- Complex expressions - AVOID! -->
      <div *ngFor="let item of items">
        {{ formatItem(item) }} - {{ calculatePrice(item) }}
      </div>
      
      <!-- Nested property access - can be expensive -->
      <span>{{ user.profile.settings.theme.primaryColor }}</span>
    </div>
  `
})
export class PerformanceAntiPatternComponent {
  items = Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `Item ${i}` }));
  user = { profile: { settings: { theme: { primaryColor: '#blue' } } } };
  
  // ❌ This runs on EVERY change detection cycle!
  getTitle() {
    console.log('getTitle called'); // Logs constantly!
    return 'My Application Title';
  }
  
  // ❌ This runs on EVERY change detection cycle!
  getItemCount() {
    console.log('getItemCount called'); // Logs constantly!
    return this.items.length;
  }
  
  // ❌ This runs on EVERY change detection cycle!
  getComplexStatus() {
    console.log('getComplexStatus called'); // Logs constantly!
    // Expensive computation
    return this.items.filter(item => item.id > 500).length > 100 ? 'High' : 'Low';
  }
  
  // ❌ This runs 1000 times per change detection cycle!
  formatItem(item: any) {
    console.log('formatItem called for:', item.id);
    return `${item.name} (ID: ${item.id})`;
  }
  
  // ❌ This runs 1000 times per change detection cycle!
  calculatePrice(item: any) {
    console.log('calculatePrice called for:', item.id);
    return item.id * 10.99;
  }
}

// ✅ Performance Optimized Version
@Component({
  template: `
    <div>
      <!-- Use component properties instead of functions -->
      <h1>{{ title }}</h1>
      <p>Items: {{ itemCount }}</p>
      <p>Status: {{ complexStatus }}</p>
      
      <!-- Pre-computed values -->
      <div *ngFor="let item of formattedItems; trackBy: trackByFn">
        {{ item.display }} - {{ item.price }}
      </div>
      
      <!-- Flatten nested properties -->
      <span>{{ primaryColor }}</span>
    </div>
  `
})
export class PerformanceOptimizedComponent implements OnInit {
  items = Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `Item ${i}` }));
  
  // ✅ Computed once, not on every cycle
  title = 'My Application Title';
  itemCount = this.items.length;
  complexStatus = this.items.filter(item => item.id > 500).length > 100 ? 'High' : 'Low';
  primaryColor = '#blue';
  
  // ✅ Pre-computed formatted items
  formattedItems: any[] = [];
  
  ngOnInit() {
    // ✅ Compute expensive operations once
    this.formattedItems = this.items.map(item => ({
      ...item,
      display: `${item.name} (ID: ${item.id})`,
      price: item.id * 10.99
    }));
  }
  
  // ✅ TrackBy function for efficient *ngFor
  trackByFn(index: number, item: any) {
    return item.id; // Use unique identifier
  }
  
  // ✅ Update computed values only when source data changes
  updateItems(newItems: any[]) {
    this.items = newItems;
    this.itemCount = newItems.length;
    this.complexStatus = newItems.filter(item => item.id > 500).length > 100 ? 'High' : 'Low';
    this.formattedItems = newItems.map(item => ({
      ...item,
      display: `${item.name} (ID: ${item.id})`,
      price: item.id * 10.99
    }));
  }
}
```
**Explanation:** Avoiding function calls in templates and pre-computing expensive operations dramatically improves performance by eliminating redundant calculations on every change detection cycle.

**Problem:** Default change detection strategy can cause severe performance issues in large applications due to checking every component on every cycle.
**Solution:** Optimize templates by avoiding function calls, pre-computing expensive operations, and using trackBy functions for efficient list rendering.
**Benefits:**
- Dramatically improved performance
- Reduced CPU usage
- Better user experience
- More predictable performance characteristics
**Implementation:** Replace template function calls with component properties, pre-compute expensive operations, and use OnPush strategy for further optimization.

---## Part 2: The Trigger (Zone.js) - Automation & Monkey Patching

### Slide: Part 2: The Trigger (Zone.js)
#### Subtitle: Automating Change Detection with Monkey Patching
Zone.js solves the fundamental question: "When should Angular run change detection?" It automates the trigger mechanism by monkey-patching browser APIs and tracking asynchronous operations.

**Highlight:** Zone.js wraps all asynchronous operations in a "zone" and emits events when a complete unit of work is finished, giving Angular the perfect moment to check for changes.

**The problem Zone.js solves:**
- Manual triggering was error-prone and tedious
- Developers had to remember to call change detection
- Forgetting to trigger resulted in stale UI
- No automatic handling of async operations
- Inconsistent behavior across different scenarios

**Code Example: The Problem: Manual Change Detection (Pre-Zone.js)**
```typescript
// AngularJS style - Manual change detection required
class ManualChangeDetectionComponent {
  data = 'initial';
  
  constructor(private scope: any) {}
  
  // ❌ Manual triggering required for DOM events
  onClick() {
    this.data = 'clicked';
    this.scope.$apply(); // Manual trigger - easy to forget!
  }
  
  // ❌ Manual triggering required for HTTP requests
  loadData() {
    fetch('/api/data')
      .then(response => response.json())
      .then(data => {
        this.data = data;
        this.scope.$apply(); // Manual trigger - easy to forget!
      });
  }
  
  // ❌ Manual triggering required for timers
  startTimer() {
    setTimeout(() => {
      this.data = 'timer finished';
      this.scope.$apply(); // Manual trigger - easy to forget!
    }, 1000);
  }
  
  // ❌ Manual triggering required for promises
  async processData() {
    const result = await this.processAsync();
    this.data = result;
    this.scope.$apply(); // Manual trigger - easy to forget!
  }
}

// The problems with manual triggering:
// 1. Easy to forget - leads to bugs
// 2. Inconsistent application behavior
// 3. Difficult to maintain
// 4. Error-prone in complex async scenarios
// 5. Requires deep framework knowledge
```
**Explanation:** Before Zone.js, developers had to manually trigger change detection after every asynchronous operation, which was error-prone and led to inconsistent UI updates.

**Problem:** Manual change detection triggering was tedious, error-prone, and often forgotten, leading to UI that didn't update when data changed.
**Solution:** Zone.js automatically detects when asynchronous operations complete and triggers change detection at the perfect moment.
**Benefits:**
- Eliminates manual triggering
- Consistent behavior across all async operations
- Reduced developer cognitive load
- Fewer bugs related to stale UI
**Implementation:** Zone.js monkey-patches browser APIs to automatically track async operations and trigger change detection when they complete.

---

### Slide: Monkey Patching: How Zone.js Works
#### Subtitle: Intercepting Browser APIs for Automatic Detection
Monkey patching is the technique of dynamically modifying existing code at runtime. Zone.js uses this to wrap browser APIs and track when asynchronous operations begin and end.

**Browser APIs that Zone.js patches:**
- DOM Events (addEventListener, onclick, etc.)
- Timers (setTimeout, setInterval, requestAnimationFrame)
- Promises (Promise.then, async/await)
- HTTP Requests (XMLHttpRequest, fetch)
- WebSocket connections
- Geolocation API
- File API operations
- MutationObserver

**Highlight:** Zone.js creates a "zone" execution context that tracks all async operations and notifies Angular when a complete "turn" of work is finished.

**Code Example: Zone.js Monkey Patching in Action**
```typescript
// Simplified example of how Zone.js patches setTimeout
// Original browser setTimeout
const originalSetTimeout = window.setTimeout;

// Zone.js patches it like this:
window.setTimeout = function(callback: Function, delay: number) {
  console.log('Zone.js: setTimeout called, starting to track...');
  
  // Wrap the callback to know when it finishes
  const wrappedCallback = function() {
    console.log('Zone.js: setTimeout callback starting...');
    
    try {
      // Execute the original callback
      callback();
    } finally {
      console.log('Zone.js: setTimeout callback finished!');
      // Notify Angular that async work is complete
      NgZone.checkStable();
    }
  };
  
  // Call the original setTimeout with wrapped callback
  return originalSetTimeout.call(this, wrappedCallback, delay);
};

// Similar patching for Promises
const originalThen = Promise.prototype.then;
Promise.prototype.then = function(onFulfilled, onRejected) {
  console.log('Zone.js: Promise.then called, tracking...');
  
  const wrappedOnFulfilled = onFulfilled ? function(value) {
    console.log('Zone.js: Promise resolved, executing callback...');
    try {
      return onFulfilled(value);
    } finally {
      console.log('Zone.js: Promise callback finished!');
      NgZone.checkStable();
    }
  } : undefined;
  
  return originalThen.call(this, wrappedOnFulfilled, onRejected);
};

// Example usage - now automatically tracked!
@Component({
  template: '<div>{{ message }}</div>'
})
export class AutomaticComponent {
  message = 'initial';
  
  ngOnInit() {
    // ✅ Zone.js automatically handles this
    setTimeout(() => {
      this.message = 'timer updated';
      // No manual change detection needed!
    }, 1000);
    
    // ✅ Zone.js automatically handles this
    fetch('/api/data')
      .then(response => response.json())
      .then(data => {
        this.message = data.message;
        // No manual change detection needed!
      });
    
    // ✅ Zone.js automatically handles this
    document.addEventListener('click', () => {
      this.message = 'clicked';
      // No manual change detection needed!
    });
  }
}

// The Zone.js "Turn" concept
// 1. Async operation starts (e.g., setTimeout)
// 2. Zone.js wraps the callback
// 3. Original operation executes
// 4. Callback executes in Zone context
// 5. Zone.js detects "turn" is complete
// 6. NgZone.onMicrotaskEmpty event fires
// 7. Angular runs change detection
```
**Explanation:** Zone.js intercepts browser APIs by replacing them with wrapped versions that track when async operations start and finish, automatically triggering change detection.

**Problem:** Browser APIs don't provide built-in notifications when asynchronous operations complete, making it impossible to know when to run change detection.
**Solution:** Zone.js monkey-patches browser APIs to wrap them with tracking logic that notifies Angular when async operations finish.
**Benefits:**
- Automatic async operation tracking
- No code changes required
- Works with all browser APIs
- Transparent to application code
**Implementation:** Zone.js patches APIs at application startup, wrapping them with zone-aware logic that tracks execution context and completion.

---

### Slide: The Zone Execution Context
#### Subtitle: Understanding Zones, Tasks, and Microtasks
A Zone is an execution context that persists across async operations. It allows Zone.js to track related async operations and know when a complete "turn" of work is finished.

**Zone.js task types:**
- MacroTasks - setTimeout, setInterval, DOM events
- MicroTasks - Promise.then, queueMicrotask
- EventTasks - addEventListener callbacks
- Task scheduling and execution tracking
- Nested zone contexts for isolation
- Zone-specific data and error handling

**Highlight:** Angular's NgZone listens for the onMicrotaskEmpty event, which fires when all microtasks in the current turn have completed.

**Code Example: Understanding Zone Execution and Task Types**
```typescript
// Zone.js execution model
class NgZoneExample {
  constructor(private ngZone: NgZone) {
    // Listen for when zone becomes stable (no pending tasks)
    this.ngZone.onStable.subscribe(() => {
      console.log('Zone is stable - all async work complete');
      // This is when Angular runs change detection!
    });
    
    this.ngZone.onUnstable.subscribe(() => {
      console.log('Zone became unstable - async work started');
    });
  }
  
  demonstrateZoneExecution() {
    console.log('1. Synchronous code starts');
    
    // MacroTask - scheduled for next event loop
    setTimeout(() => {
      console.log('4. MacroTask (setTimeout) executes');
      
      // MicroTask inside MacroTask
      Promise.resolve().then(() => {
        console.log('5. MicroTask (Promise) executes');
        // Zone becomes stable after this
      });
    }, 0);
    
    // MicroTask - executes before MacroTasks
    Promise.resolve().then(() => {
      console.log('3. MicroTask (Promise) executes first');
    });
    
    console.log('2. Synchronous code continues');
    
    // Execution order:
    // 1. Synchronous code starts
    // 2. Synchronous code continues  
    // 3. MicroTask (Promise) executes first
    // 4. MacroTask (setTimeout) executes
    // 5. MicroTask (Promise) executes
    // -> Zone becomes stable -> Change detection runs
  }
  
  // Running code outside Angular zone
  runOutsideAngular() {
    this.ngZone.runOutsideAngular(() => {
      // This won't trigger change detection
      setInterval(() => {
        console.log('Running outside Angular zone');
        // No change detection triggered!
      }, 1000);
    });
  }
  
  // Manually triggering change detection
  runInsideAngular() {
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        // Do work outside zone
        const result = this.expensiveOperation();
        
        // Re-enter zone to trigger change detection
        this.ngZone.run(() => {
          this.updateUI(result);
          // Change detection will run after this
        });
      }, 1000);
    });
  }
}

// Advanced Zone.js concepts
class AdvancedZoneExample {
  // Creating custom zones
  createCustomZone() {
    const customZone = Zone.current.fork({
      name: 'customZone',
      onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
        console.log('Task starting:', task.source);
        const result = delegate.invokeTask(target, task, applyThis, applyArgs);
        console.log('Task finished:', task.source);
        return result;
      }
    });
    
    customZone.run(() => {
      // All async operations in this zone will be tracked
      setTimeout(() => console.log('Custom zone timer'), 100);
    });
  }
  
  // Zone error handling
  handleZoneErrors() {
    Zone.current.fork({
      name: 'errorHandlingZone',
      onHandleError: (delegate, current, target, error) => {
        console.error('Zone caught error:', error);
        return false; // Don't propagate
      }
    }).run(() => {
      setTimeout(() => {
        throw new Error('Async error in zone');
      }, 100);
    });
  }
}
```
**Explanation:** Zone.js creates execution contexts that track async operations through macrotasks and microtasks, providing precise control over when change detection should run.

**Problem:** JavaScript's event loop makes it difficult to know when all related async operations have completed, making it hard to determine the right moment for change detection.
**Solution:** Zone.js creates execution contexts that track all async operations and provide events when the zone becomes stable (no pending work).
**Benefits:**
- Precise async operation tracking
- Stable/unstable zone events
- Custom zone creation for isolation
- Error handling across async boundaries
**Implementation:** NgZone wraps the Angular application in a zone that listens for stability events and triggers change detection when all async work is complete.

---

### Slide: NgZone: Angular's Zone.js Integration
#### Subtitle: How Angular Uses Zone.js for Change Detection
NgZone is Angular's service that wraps Zone.js functionality and provides the bridge between zone events and Angular's change detection system.

**NgZone responsibilities:**
- Wraps the Angular application in a zone
- Listens for onMicrotaskEmpty events
- Triggers ApplicationRef.tick() for change detection
- Provides methods to run code inside/outside the zone
- Handles zone-related errors and debugging
- Offers fine-grained control over change detection timing

**Highlight:** NgZone.onMicrotaskEmpty is the key event that triggers Angular's change detection cycle.

**Code Example: NgZone Integration and Control**
```typescript
@Injectable()
export class NgZoneService {
  constructor(private ngZone: NgZone) {
    this.setupZoneListeners();
  }
  
  private setupZoneListeners() {
    // Key event: when zone becomes stable
    this.ngZone.onStable.subscribe(() => {
      console.log('🟢 Zone stable - change detection will run');
    });
    
    // When zone becomes unstable (async work starts)
    this.ngZone.onUnstable.subscribe(() => {
      console.log('🔴 Zone unstable - async work started');
    });
    
    // When microtask queue is empty
    this.ngZone.onMicrotaskEmpty.subscribe(() => {
      console.log('✅ Microtask queue empty - triggering change detection');
      // This is where ApplicationRef.tick() gets called!
    });
    
    // Zone errors
    this.ngZone.onError.subscribe((error) => {
      console.error('❌ Zone error:', error);
    });
  }
  
  // Performance optimization: run outside Angular zone
  performHeavyWork() {
    this.ngZone.runOutsideAngular(() => {
      // Heavy computation that doesn't need change detection
      const canvas = document.getElementById('canvas') as HTMLCanvasElement;
      const ctx = canvas.getContext('2d')!;
      
      // Animation loop outside zone - no change detection overhead
      const animate = () => {
        // Draw frame
        this.drawFrame(ctx);
        requestAnimationFrame(animate);
      };
      animate();
    });
  }
  
  // Re-enter zone when you need change detection
  updateUIAfterHeavyWork(result: any) {
    this.ngZone.run(() => {
      // This will trigger change detection
      this.updateComponentState(result);
    });
  }
  
  // Batch multiple operations
  batchOperations() {
    this.ngZone.runOutsideAngular(() => {
      // Multiple async operations outside zone
      const promises = [
        this.operation1(),
        this.operation2(),
        this.operation3()
      ];
      
      Promise.all(promises).then(results => {
        // Re-enter zone once for all results
        this.ngZone.run(() => {
          this.processResults(results);
          // Single change detection cycle for all operations
        });
      });
    });
  }
}

// Component using NgZone
@Component({
  selector: 'app-zone-demo',
  template: `
    <div>
      <h3>Zone Demo</h3>
      <p>Counter: {{ counter }}</p>
      <p>Heavy Result: {{ heavyResult }}</p>
      <button (click)="normalUpdate()">Normal Update</button>
      <button (click)="optimizedUpdate()">Optimized Update</button>
    </div>
  `
})
export class ZoneDemoComponent {
  counter = 0;
  heavyResult = '';
  
  constructor(private ngZone: NgZone) {}
  
  // ❌ Normal update - triggers change detection
  normalUpdate() {
    // This runs inside Angular zone
    setTimeout(() => {
      this.counter++;
      // Change detection runs automatically
    }, 100);
  }
  
  // ✅ Optimized update - controlled change detection
  optimizedUpdate() {
    this.ngZone.runOutsideAngular(() => {
      // Heavy work outside zone
      setTimeout(() => {
        const result = this.performHeavyCalculation();
        
        // Re-enter zone only when needed
        this.ngZone.run(() => {
          this.heavyResult = result;
          // Change detection runs once
        });
      }, 100);
    });
  }
  
  private performHeavyCalculation(): string {
    // Simulate heavy work
    let result = '';
    for (let i = 0; i < 1000000; i++) {
      result += Math.random().toString();
    }
    return result.substring(0, 10);
  }
}

// The complete flow:
// 1. User clicks button (DOM event)
// 2. Zone.js intercepts the event
// 3. Event handler executes in Angular zone
// 4. Any async operations are tracked
// 5. When all async work completes, zone becomes stable
// 6. NgZone.onMicrotaskEmpty fires
// 7. ApplicationRef.tick() is called
// 8. Change detection runs from root component
```
**Explanation:** NgZone provides the integration layer between Zone.js and Angular, offering fine-grained control over when change detection runs and allowing performance optimizations.

**Problem:** Raw Zone.js doesn't integrate directly with Angular's change detection system, and developers need control over when change detection runs.
**Solution:** NgZone provides Angular-specific integration with Zone.js, offering events and methods to control change detection timing.
**Benefits:**
- Automatic change detection triggering
- Performance optimization capabilities
- Fine-grained control over detection timing
- Integration with Angular's lifecycle
**Implementation:** Inject NgZone service and use runOutsideAngular() for performance-critical code, then run() to re-enter when change detection is needed.

---

### Slide: Zone.js Performance Considerations
#### Subtitle: Understanding the Overhead and Optimization Strategies
While Zone.js provides automatic change detection, it comes with performance overhead. Understanding these implications helps in building efficient Angular applications.

**Zone.js performance implications:**
- Monkey patching adds overhead to all async operations
- Frequent async operations trigger many change detection cycles
- Large component trees amplify the performance impact
- Third-party libraries may trigger unexpected cycles
- Memory overhead from tracking async operations
- Debugging complexity in heavily async applications

**Comparison: Zone.js Trade-offs:**
- **Before:** Automatic, transparent change detection with some performance overhead
- **After:** Manual control required but maximum performance with zoneless approach

**Code Example: Zone.js Performance Optimization Strategies**
```typescript
// Performance monitoring and optimization
@Component({
  selector: 'app-performance-demo',
  template: `
    <div>
      <h3>Performance Demo</h3>
      <p>Updates: {{ updateCount }}</p>
      <canvas #canvas width="400" height="300"></canvas>
      <button (click)="startAnimation()">Start Animation</button>
      <button (click)="stopAnimation()">Stop Animation</button>
    </div>
  `
})
export class PerformanceDemoComponent implements OnInit, OnDestroy {
  @ViewChild('canvas', { static: true }) canvas!: ElementRef<HTMLCanvasElement>;
  
  updateCount = 0;
  private animationId?: number;
  private isAnimating = false;
  
  constructor(private ngZone: NgZone) {}
  
  ngOnInit() {
    this.measureZoneOverhead();
  }
  
  // ❌ Animation inside zone - triggers change detection on every frame
  startBadAnimation() {
    const ctx = this.canvas.nativeElement.getContext('2d')!;
    let frame = 0;
    
    const animate = () => {
      if (!this.isAnimating) return;
      
      // This runs inside Angular zone
      ctx.clearRect(0, 0, 400, 300);
      ctx.fillRect(frame % 400, 150, 50, 50);
      frame++;
      
      this.updateCount++; // Triggers change detection!
      requestAnimationFrame(animate); // Zone.js patches this!
    };
    
    this.isAnimating = true;
    animate(); // 60 FPS = 60 change detection cycles per second!
  }
  
  // ✅ Optimized animation outside zone
  startAnimation() {
    this.ngZone.runOutsideAngular(() => {
      const ctx = this.canvas.nativeElement.getContext('2d')!;
      let frame = 0;
      let lastUpdate = Date.now();
      
      const animate = () => {
        if (!this.isAnimating) return;
        
        // Animation logic outside zone - no change detection
        ctx.clearRect(0, 0, 400, 300);
        ctx.fillRect(frame % 400, 150, 50, 50);
        frame++;
        
        // Update UI occasionally, not every frame
        const now = Date.now();
        if (now - lastUpdate > 1000) { // Every second
          this.ngZone.run(() => {
            this.updateCount++;
            // Change detection runs only once per second
          });
          lastUpdate = now;
        }
        
        requestAnimationFrame(animate);
      };
      
      this.isAnimating = true;
      animate();
    });
  }
  
  stopAnimation() {
    this.isAnimating = false;
  }
  
  // Measure Zone.js overhead
  private measureZoneOverhead() {
    const iterations = 10000;
    
    // Measure inside zone
    const startInside = performance.now();
    for (let i = 0; i < iterations; i++) {
      setTimeout(() => {}, 0); // Zone.js patches this
    }
    const endInside = performance.now();
    
    // Measure outside zone
    this.ngZone.runOutsideAngular(() => {
      const startOutside = performance.now();
      for (let i = 0; i < iterations; i++) {
        setTimeout(() => {}, 0); // No Zone.js overhead
      }
      const endOutside = performance.now();
      
      console.log(`Zone.js overhead: ${endInside - startInside}ms vs ${endOutside - startOutside}ms`);
    });
  }
  
  ngOnDestroy() {
    this.stopAnimation();
  }
}

// Third-party library integration
@Injectable()
export class ThirdPartyIntegrationService {
  constructor(private ngZone: NgZone) {}
  
  // ❌ Third-party library triggering excessive change detection
  setupBadLibraryIntegration() {
    // Library that fires events frequently
    const library = new SomeThirdPartyLibrary();
    
    library.onUpdate((data) => {
      // This runs inside Angular zone
      this.processData(data);
      // Change detection runs on every library update!
    });
  }
  
  // ✅ Optimized third-party integration
  setupOptimizedLibraryIntegration() {
    this.ngZone.runOutsideAngular(() => {
      const library = new SomeThirdPartyLibrary();
      let pendingUpdate = false;
      
      library.onUpdate((data) => {
        // Process data outside zone
        this.processDataOutsideZone(data);
        
        // Batch UI updates
        if (!pendingUpdate) {
          pendingUpdate = true;
          setTimeout(() => {
            this.ngZone.run(() => {
              this.updateUI();
              pendingUpdate = false;
            });
          }, 16); // ~60fps batching
        }
      });
    });
  }
  
  private processData(data: any) {
    // Process data that triggers change detection
  }
  
  private processDataOutsideZone(data: any) {
    // Process data without triggering change detection
  }
  
  private updateUI() {
    // Update Angular components
  }
}

// Performance monitoring
@Injectable()
export class ZonePerformanceMonitor {
  private changeDetectionCount = 0;
  private lastReset = Date.now();
  
  constructor(private ngZone: NgZone) {
    this.setupMonitoring();
  }
  
  private setupMonitoring() {
    this.ngZone.onStable.subscribe(() => {
      this.changeDetectionCount++;
      
      const now = Date.now();
      if (now - this.lastReset > 5000) { // Every 5 seconds
        console.log(`Change detection cycles in last 5s: ${this.changeDetectionCount}`);
        this.changeDetectionCount = 0;
        this.lastReset = now;
      }
    });
  }
}
```
**Explanation:** Zone.js adds overhead to async operations and can trigger excessive change detection. Use runOutsideAngular() for performance-critical code and batch UI updates.

**Problem:** Zone.js monkey patching adds overhead to all async operations and can trigger excessive change detection cycles in performance-critical applications.
**Solution:** Use NgZone.runOutsideAngular() for performance-critical code and batch UI updates to minimize change detection overhead.
**Benefits:**
- Reduced change detection frequency
- Better animation performance
- Optimized third-party library integration
- Lower CPU usage
**Implementation:** Run performance-critical code outside Angular zone and re-enter only when UI updates are needed, batching multiple operations together.

---## Part 3: The Optimization (OnPush) - Skipping Subtrees for Better Performance

### Slide: Part 3: The Optimization (OnPush)
#### Subtitle: Skipping Subtrees for Better Performance
ChangeDetectionStrategy.OnPush is Angular's solution to the performance problem of checking every component on every cycle. It allows Angular to skip checking a component and its entire subtree unless specific conditions are met.

**Highlight:** OnPush transforms components into "pure" components, meaning their view should only change if their inputs change by reference or specific events occur.

**The problem OnPush solves:**
- Default strategy checks every component on every cycle
- Large component trees create performance bottlenecks
- Unnecessary checks for components that haven't changed
- Zone.js triggers can be very frequent
- CPU waste on redundant comparisons
- Poor user experience in complex applications

**Code Example: OnPush Strategy Basic Implementation**
```typescript
// ❌ Default Strategy - Always Checked
@Component({
  selector: 'app-user-card-default',
  // Default strategy (ChangeDetectionStrategy.Default) is implicit
  template: `
    <div class="user-card">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <p>Last seen: {{ formatDate(user.lastSeen) }}</p>
      <span class="status">{{ getStatusText() }}</span>
    </div>
  `
})
export class UserCardDefaultComponent {
  @Input() user!: User;
  
  formatDate(date: Date) {
    console.log('formatDate called!'); // Logs on EVERY change detection cycle!
    return date.toLocaleDateString();
  }
  
  getStatusText() {
    console.log('getStatusText called!'); // Logs on EVERY change detection cycle!
    return this.user.isOnline ? 'Online' : 'Offline';
  }
}

// ✅ OnPush Strategy - Optimized Checking
@Component({
  selector: 'app-user-card-onpush',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="user-card">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <p>Last seen: {{ formattedDate }}</p>
      <span class="status">{{ statusText }}</span>
      <button (click)="onEditClick()">Edit</button>
    </div>
  `
})
export class UserCardOnPushComponent implements OnChanges {
  @Input() user!: User;
  @Output() editUser = new EventEmitter<User>();
  
  // Pre-computed values - calculated only when inputs change
  formattedDate = '';
  statusText = '';
  
  ngOnChanges(changes: SimpleChanges) {
    if (changes['user']) {
      console.log('OnPush: Input changed, recalculating...');
      this.formattedDate = this.user.lastSeen.toLocaleDateString();
      this.statusText = this.user.isOnline ? 'Online' : 'Offline';
    }
  }
  
  onEditClick() {
    // Event emission triggers change detection for this component
    this.editUser.emit(this.user);
  }
}

// Usage comparison
@Component({
  template: `
    <div>
      <!-- Both components receive the same data -->
      <app-user-card-default [user]="currentUser"></app-user-card-default>
      <app-user-card-onpush [user]="currentUser" (editUser)="editUser($event)"></app-user-card-onpush>
      
      <!-- Unrelated update that triggers change detection -->
      <button (click)="updateCounter()">Counter: {{ counter }}</button>
    </div>
  `
})
export class ComparisonComponent {
  currentUser: User = { name: 'John', email: 'john@example.com', lastSeen: new Date(), isOnline: true };
  counter = 0;
  
  updateCounter() {
    this.counter++;
    // Default component: formatDate() and getStatusText() will run
    // OnPush component: No methods will run (input didn't change)
  }
  
  editUser(user: User) {
    console.log('Editing user:', user);
  }
}
```
**Explanation:** OnPush components only run change detection when inputs change by reference or events are emitted, dramatically reducing unnecessary checks.

**Problem:** Default change detection checks every component on every cycle, causing performance issues in applications with many components or complex templates.
**Solution:** OnPush strategy allows Angular to skip checking components and their subtrees unless specific conditions are met, dramatically improving performance.
**Benefits:**
- Significant performance improvement
- Reduced CPU usage
- Better scalability for large applications
- Predictable change detection behavior
**Implementation:** Set changeDetection: ChangeDetectionStrategy.OnPush in component decorator and ensure proper input handling patterns.

---

### Slide: OnPush Triggers: When Change Detection Runs
#### Subtitle: Understanding the Four Conditions
OnPush components only trigger change detection under four specific conditions. Understanding these conditions is crucial for building reliable OnPush components.

**OnPush change detection triggers:**
- 1. Input property receives a new reference (not mutation)
- 2. Event handler is fired within the component or its children
- 3. Async pipe receives a new value from an Observable
- 4. Manual trigger via ChangeDetectorRef.markForCheck()

**Highlight:** OnPush relies on reference equality checks. Mutating existing objects will NOT trigger change detection!

**Code Example: OnPush Triggers Detailed Examples**
```typescript
@Component({
  selector: 'app-onpush-triggers',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <h3>{{ user.name }}</h3>
      <p>Posts: {{ user.posts.length }}</p>
      <p>Last update: {{ lastUpdate$ | async | date:'medium' }}</p>
      
      <button (click)="handleClick()">Click Me</button>
      <child-component (childEvent)="handleChildEvent($event)"></child-component>
    </div>
  `
})
export class OnPushTriggersComponent {
  @Input() user!: User;
  
  // Observable for async pipe trigger
  lastUpdate$ = new BehaviorSubject(new Date());
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  // Trigger 2: Event handler execution
  handleClick() {
    console.log('Button clicked - change detection will run');
    // This event handler execution triggers change detection
  }
  
  // Trigger 2: Child event handler
  handleChildEvent(data: any) {
    console.log('Child event received - change detection will run');
    // Events from child components also trigger change detection
  }
  
  // Trigger 4: Manual change detection
  updateDataManually() {
    // Some external data update that OnPush won't detect
    this.updateExternalData();
    
    // Manually mark for check
    this.cdr.markForCheck();
    console.log('Manually marked for check - change detection will run');
  }
  
  // Trigger 3: Async pipe with new Observable value
  updateLastUpdate() {
    this.lastUpdate$.next(new Date());
    // Async pipe will automatically trigger change detection
  }
  
  private updateExternalData() {
    // External API call or data update
  }
}

// Parent component demonstrating input triggers
@Component({
  template: `
    <app-onpush-triggers [user]="currentUser"></app-onpush-triggers>
    
    <div>
      <button (click)="mutateUser()">❌ Mutate User (Won't Work)</button>
      <button (click)="updateUserImmutable()">✅ Update User (Will Work)</button>
      <button (click)="addPost()">Add Post</button>
    </div>
  `
})
export class ParentComponent {
  currentUser: User = {
    name: 'John',
    email: 'john@example.com',
    posts: []
  };
  
  // ❌ Trigger 1: This WON'T work with OnPush
  mutateUser() {
    this.currentUser.name = 'Jane'; // Same object reference!
    console.log('User mutated - OnPush component WON\'T update');
    // OnPush component won't detect this change
  }
  
  // ✅ Trigger 1: This WILL work with OnPush
  updateUserImmutable() {
    this.currentUser = {
      ...this.currentUser,
      name: 'Jane'
    }; // New object reference!
    console.log('User updated immutably - OnPush component WILL update');
  }
  
  // ✅ Trigger 1: Array updates with new reference
  addPost() {
    this.currentUser = {
      ...this.currentUser,
      posts: [...this.currentUser.posts, { id: Date.now(), title: 'New Post' }]
    };
    console.log('Post added immutably - OnPush component WILL update');
  }
}

// Advanced: Conditional OnPush triggers
@Component({
  selector: 'app-conditional-onpush',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <h3>Conditional Updates</h3>
      <p>Count: {{ count }}</p>
      <p>Should update: {{ shouldUpdate }}</p>
    </div>
  `
})
export class ConditionalOnPushComponent implements OnChanges {
  @Input() data: any;
  
  count = 0;
  shouldUpdate = false;
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  ngOnChanges(changes: SimpleChanges) {
    if (changes['data']) {
      // Custom logic to determine if update is needed
      const oldValue = changes['data'].previousValue;
      const newValue = changes['data'].currentValue;
      
      this.shouldUpdate = this.hasSignificantChange(oldValue, newValue);
      
      if (this.shouldUpdate) {
        this.count++;
        console.log('Significant change detected, updating component');
      } else {
        // Even though input changed, we decide not to update
        console.log('Change not significant, skipping update');
        // Could call cdr.detach() to prevent this cycle
      }
    }
  }
  
  private hasSignificantChange(oldValue: any, newValue: any): boolean {
    // Custom comparison logic
    if (!oldValue || !newValue) return true;
    
    // Only update if certain properties changed
    return oldValue.importantField !== newValue.importantField;
  }
}
```
**Explanation:** OnPush components have four specific triggers. Understanding and properly implementing these triggers is essential for reliable OnPush behavior.

**Problem:** Developers often struggle with OnPush components not updating when expected, usually due to object mutations instead of reference changes.
**Solution:** Understanding the four OnPush triggers and implementing proper immutable update patterns ensures reliable component updates.
**Benefits:**
- Predictable component update behavior
- Better performance through selective updates
- Clear understanding of when updates occur
- Easier debugging of change detection issues
**Implementation:** Use immutable update patterns for inputs, leverage async pipe for observables, and use ChangeDetectorRef for manual control when needed.

---

### Slide: Immutability Patterns for OnPush
#### Subtitle: Mastering Reference-Based Change Detection
OnPush strategy requires immutable data patterns to work correctly. Understanding and implementing these patterns is crucial for OnPush success.

**Comparison: Mutable vs Immutable Patterns:**
- **Before:** Mutable: Modifies existing objects, same reference, OnPush won't detect changes
- **After:** Immutable: Creates new objects, new reference, OnPush detects changes reliably

**Benefits of immutable patterns:**
- Guaranteed OnPush compatibility
- Predictable change detection behavior
- Time-travel debugging capabilities
- Better performance with proper memoization
- Easier testing and reasoning about state
- Integration with state management libraries

**Code Example: Comprehensive Immutability Patterns**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  profile: {
    avatar: string;
    preferences: {
      theme: string;
      notifications: boolean;
    };
  };
  posts: Post[];
  tags: string[];
}

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ImmutabilityPatternsComponent {
  users: User[] = [];
  
  // ❌ MUTABLE PATTERNS - DON'T DO THIS WITH ONPUSH
  
  updateUserMutable(userId: number, newName: string) {
    const user = this.users.find(u => u.id === userId);
    if (user) {
      user.name = newName; // ❌ Mutating existing object
      user.profile.preferences.theme = 'dark'; // ❌ Nested mutation
    }
    // OnPush components won't detect these changes!
  }
  
  addUserMutable(newUser: User) {
    this.users.push(newUser); // ❌ Mutating existing array
    // OnPush components won't detect this change!
  }
  
  // ✅ IMMUTABLE PATTERNS - CORRECT FOR ONPUSH
  
  // Object updates with spread operator
  updateUserImmutable(userId: number, newName: string) {
    this.users = this.users.map(user =>
      user.id === userId
        ? { ...user, name: newName } // ✅ New object reference
        : user
    );
  }
  
  // Nested object updates
  updateUserTheme(userId: number, theme: string) {
    this.users = this.users.map(user =>
      user.id === userId
        ? {
            ...user,
            profile: {
              ...user.profile,
              preferences: {
                ...user.profile.preferences,
                theme // ✅ Immutable nested update
              }
            }
          }
        : user
    );
  }
  
  // Array operations
  addUserImmutable(newUser: User) {
    this.users = [...this.users, newUser]; // ✅ New array reference
  }
  
  removeUser(userId: number) {
    this.users = this.users.filter(user => user.id !== userId); // ✅ New array
  }
  
  updateUserAtIndex(index: number, updates: Partial<User>) {
    this.users = [
      ...this.users.slice(0, index),
      { ...this.users[index], ...updates },
      ...this.users.slice(index + 1)
    ]; // ✅ New array with updated object
  }
  
  // Array of objects updates
  addPostToUser(userId: number, newPost: Post) {
    this.users = this.users.map(user =>
      user.id === userId
        ? {
            ...user,
            posts: [...user.posts, newPost] // ✅ New posts array
          }
        : user
    );
  }
  
  updatePostInUser(userId: number, postId: number, updates: Partial<Post>) {
    this.users = this.users.map(user =>
      user.id === userId
        ? {
            ...user,
            posts: user.posts.map(post =>
              post.id === postId
                ? { ...post, ...updates } // ✅ New post object
                : post
            )
          }
        : user
    );
  }
  
  // Complex state updates with helper functions
  updateUserProfile(userId: number, profileUpdates: Partial<User['profile']>) {
    this.users = this.updateUserById(userId, user => ({
      ...user,
      profile: { ...user.profile, ...profileUpdates }
    }));
  }
  
  // Helper function for cleaner updates
  private updateUserById(userId: number, updateFn: (user: User) => User): User[] {
    return this.users.map(user =>
      user.id === userId ? updateFn(user) : user
    );
  }
  
  // Batch updates
  batchUpdateUsers(updates: { userId: number; changes: Partial<User> }[]) {
    this.users = this.users.map(user => {
      const update = updates.find(u => u.userId === user.id);
      return update ? { ...user, ...update.changes } : user;
    });
  }
}

// Using Immer for complex immutable updates
import { produce } from 'immer';

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ImmerPatternsComponent {
  users: User[] = [];
  
  // ✅ Using Immer for complex updates
  updateUserWithImmer(userId: number, updates: Partial<User>) {
    this.users = produce(this.users, draft => {
      const user = draft.find(u => u.id === userId);
      if (user) {
        // Immer allows "mutable" syntax but creates immutable result
        Object.assign(user, updates);
      }
    });
  }
  
  // Complex nested updates with Immer
  updateNestedPreference(userId: number, key: string, value: any) {
    this.users = produce(this.users, draft => {
      const user = draft.find(u => u.id === userId);
      if (user) {
        user.profile.preferences[key] = value; // Looks mutable but isn't!
      }
    });
  }
  
  // Array manipulations with Immer
  reorderPosts(userId: number, fromIndex: number, toIndex: number) {
    this.users = produce(this.users, draft => {
      const user = draft.find(u => u.id === userId);
      if (user) {
        const [movedPost] = user.posts.splice(fromIndex, 1);
        user.posts.splice(toIndex, 0, movedPost);
      }
    });
  }
}

// Performance considerations
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class PerformantImmutableComponent {
  largeDataSet: any[] = [];
  
  // ✅ Efficient updates for large datasets
  updateItemEfficiently(id: number, updates: any) {
    // Find index first to avoid multiple iterations
    const index = this.largeDataSet.findIndex(item => item.id === id);
    if (index !== -1) {
      this.largeDataSet = [
        ...this.largeDataSet.slice(0, index),
        { ...this.largeDataSet[index], ...updates },
        ...this.largeDataSet.slice(index + 1)
      ];
    }
  }
  
  // ✅ Batch updates for better performance
  batchUpdateItems(updates: Map<number, any>) {
    this.largeDataSet = this.largeDataSet.map(item =>
      updates.has(item.id)
        ? { ...item, ...updates.get(item.id) }
        : item
    );
  }
  
  // ✅ Memoized selectors for derived data
  @memoize()
  getFilteredItems(filter: string): any[] {
    return this.largeDataSet.filter(item =>
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }
}
```
**Explanation:** Immutable patterns ensure OnPush components detect changes reliably. Use spread operators, array methods, or libraries like Immer for complex updates.

**Problem:** OnPush strategy requires reference changes to detect updates, but developers often use mutable operations that don't create new references.
**Solution:** Adopt comprehensive immutable data patterns that create new object references for every change, ensuring OnPush components detect all updates.
**Benefits:**
- Guaranteed OnPush compatibility
- Predictable change detection behavior
- Better debugging and testing experience
- Time-travel debugging capabilities
- Performance benefits with memoization
**Implementation:** Use spread operators, Object.assign, Array methods like map/filter, or libraries like Immer for complex immutable updates.

---

### Slide: OnPush with Observables and Async Pipe
#### Subtitle: Reactive Programming with OnPush Strategy
The async pipe is perfectly designed for OnPush components. It automatically handles subscriptions and triggers change detection when new values arrive.

**Async pipe benefits with OnPush:**
- Automatically triggers change detection on new values
- Handles subscription management (subscribe/unsubscribe)
- Works seamlessly with OnPush strategy
- Prevents memory leaks
- Supports both Observables and Promises
- Handles null/undefined values gracefully

**Highlight:** The async pipe is the recommended pattern for consuming Observables in OnPush components, eliminating the need for manual subscription management.

**Code Example: OnPush with Reactive Patterns**
```typescript
@Component({
  selector: 'app-reactive-onpush',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="reactive-component">
      <!-- ✅ Async pipe automatically triggers OnPush -->
      <div *ngIf="loading$ | async" class="loading">Loading...</div>
      
      <div *ngFor="let user of users$ | async; trackBy: trackByUserId">
        <h3>{{ user.name }}</h3>
        <p>{{ user.email }}</p>
      </div>
      
      <!-- ✅ Multiple async pipes work perfectly -->
      <div class="stats">
        <p>Total: {{ (users$ | async)?.length || 0 }}</p>
        <p>Online: {{ onlineCount$ | async }}</p>
        <p>Last Update: {{ lastUpdate$ | async | date:'medium' }}</p>
      </div>
      
      <!-- ✅ Error handling with async pipe -->
      <div *ngIf="error$ | async as error" class="error">
        Error: {{ error.message }}
      </div>
      
      <!-- ✅ Complex derived data -->
      <div class="summary">
        <h4>Department Summary</h4>
        <div *ngFor="let dept of departmentSummary$ | async">
          {{ dept.name }}: {{ dept.count }} users ({{ dept.percentage }}%)
        </div>
      </div>
    </div>
  `
})
export class ReactiveOnPushComponent implements OnInit {
  // Base observables
  users$: Observable<User[]>;
  loading$: Observable<boolean>;
  error$: Observable<Error | null>;
  
  // Derived observables
  onlineCount$: Observable<number>;
  lastUpdate$: Observable<Date>;
  departmentSummary$: Observable<DepartmentSummary[]>;
  
  constructor(private userService: UserService) {}
  
  ngOnInit() {
    // ✅ Create reactive data streams
    this.users$ = this.userService.getUsers().pipe(
      shareReplay(1), // Cache latest value
      catchError(error => {
        console.error('Error loading users:', error);
        return of([]); // Fallback to empty array
      })
    );
    
    this.loading$ = this.userService.loading$;
    this.error$ = this.userService.error$;
    
    // ✅ Derived observables - automatically update when source changes
    this.onlineCount$ = this.users$.pipe(
      map(users => users.filter(user => user.isOnline).length)
    );
    
    this.lastUpdate$ = this.users$.pipe(
      map(() => new Date()),
      startWith(new Date())
    );
    
    // ✅ Complex transformations
    this.departmentSummary$ = this.users$.pipe(
      map(users => this.calculateDepartmentSummary(users))
    );
  }
  
  // ✅ TrackBy function for performance
  trackByUserId(index: number, user: User): number {
    return user.id;
  }
  
  private calculateDepartmentSummary(users: User[]): DepartmentSummary[] {
    const deptMap = new Map<string, number>();
    users.forEach(user => {
      const count = deptMap.get(user.department) || 0;
      deptMap.set(user.department, count + 1);
    });
    
    const total = users.length;
    return Array.from(deptMap.entries()).map(([name, count]) => ({
      name,
      count,
      percentage: Math.round((count / total) * 100)
    }));
  }
}

// ❌ Anti-pattern: Manual subscription in OnPush
@Component({
  selector: 'app-manual-subscription',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <p>Users: {{ users.length }}</p>
      <p>Loading: {{ isLoading }}</p>
    </div>
  `
})
export class ManualSubscriptionComponent implements OnInit, OnDestroy {
  users: User[] = [];
  isLoading = false;
  private subscription = new Subscription();
  
  constructor(
    private userService: UserService,
    private cdr: ChangeDetectorRef // ❌ Need manual change detection
  ) {}
  
  ngOnInit() {
    // ❌ Manual subscription management required
    this.subscription.add(
      this.userService.getUsers().subscribe(users => {
        this.users = users;
        this.cdr.markForCheck(); // ❌ Manual trigger needed
      })
    );
    
    this.subscription.add(
      this.userService.loading$.subscribe(loading => {
        this.isLoading = loading;
        this.cdr.markForCheck(); // ❌ Manual trigger needed
      })
    );
  }
  
  ngOnDestroy() {
    this.subscription.unsubscribe(); // ❌ Manual cleanup required
  }
}

// ✅ Advanced reactive patterns with OnPush
@Component({
  selector: 'app-advanced-reactive',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <!-- Search input -->
      <input #searchInput (input)="onSearchInput(searchInput.value)" placeholder="Search users...">
      
      <!-- Filtered results -->
      <div *ngFor="let user of filteredUsers$ | async">
        {{ user.name }} - {{ user.department }}
      </div>
      
      <!-- Pagination -->
      <div class="pagination">
        <button (click)="previousPage()" [disabled]="(currentPage$ | async) === 1">Previous</button>
        <span>Page {{ currentPage$ | async }} of {{ totalPages$ | async }}</span>
        <button (click)="nextPage()" [disabled]="(currentPage$ | async) === (totalPages$ | async)">Next</button>
      </div>
    </div>
  `
})
export class AdvancedReactiveComponent implements OnInit {
  private searchSubject = new BehaviorSubject<string>('');
  private pageSubject = new BehaviorSubject<number>(1);
  private pageSize = 10;
  
  // Reactive streams
  search$ = this.searchSubject.asObservable();
  currentPage$ = this.pageSubject.asObservable();
  
  allUsers$: Observable<User[]>;
  filteredUsers$: Observable<User[]>;
  totalPages$: Observable<number>;
  
  constructor(private userService: UserService) {}
  
  ngOnInit() {
    this.allUsers$ = this.userService.getUsers();
    
    // ✅ Reactive search with debouncing
    const searchResults$ = combineLatest([
      this.allUsers$,
      this.search$.pipe(
        debounceTime(300),
        distinctUntilChanged()
      )
    ]).pipe(
      map(([users, searchTerm]) =>
        searchTerm
          ? users.filter(user =>
              user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              user.department.toLowerCase().includes(searchTerm.toLowerCase())
            )
          : users
      )
    );
    
    // ✅ Reactive pagination
    this.filteredUsers$ = combineLatest([
      searchResults$,
      this.currentPage$
    ]).pipe(
      map(([users, page]) => {
        const startIndex = (page - 1) * this.pageSize;
        return users.slice(startIndex, startIndex + this.pageSize);
      })
    );
    
    this.totalPages$ = searchResults$.pipe(
      map(users => Math.ceil(users.length / this.pageSize))
    );
    
    // ✅ Reset to first page when search changes
    this.search$.pipe(
      skip(1), // Skip initial value
      distinctUntilChanged()
    ).subscribe(() => {
      this.pageSubject.next(1);
    });
  }
  
  onSearchInput(value: string) {
    this.searchSubject.next(value);
  }
  
  nextPage() {
    this.pageSubject.next(this.pageSubject.value + 1);
  }
  
  previousPage() {
    this.pageSubject.next(Math.max(1, this.pageSubject.value - 1));
  }
}

// Service supporting reactive patterns
@Injectable()
export class ReactiveUserService {
  private usersSubject = new BehaviorSubject<User[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private errorSubject = new BehaviorSubject<Error | null>(null);
  
  // Public observables
  users$ = this.usersSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  error$ = this.errorSubject.asObservable();
  
  constructor(private http: HttpClient) {}
  
  getUsers(): Observable<User[]> {
    this.loadingSubject.next(true);
    this.errorSubject.next(null);
    
    return this.http.get<User[]>('/api/users').pipe(
      tap(users => {
        this.usersSubject.next(users);
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error);
        this.loadingSubject.next(false);
        return throwError(error);
      })
    );
  }
  
  updateUser(user: User): Observable<User> {
    return this.http.put<User>(`/api/users/${user.id}`, user).pipe(
      tap(updatedUser => {
        const currentUsers = this.usersSubject.value;
        const updatedUsers = currentUsers.map(u =>
          u.id === updatedUser.id ? updatedUser : u
        );
        this.usersSubject.next(updatedUsers);
      })
    );
  }
}
```
**Explanation:** The async pipe is the perfect companion for OnPush components, automatically handling subscriptions and triggering change detection when observables emit new values.

**Problem:** Manual subscription management in OnPush components is complex, error-prone, and requires manual change detection triggering.
**Solution:** The async pipe provides automatic subscription management and change detection triggering, making reactive programming with OnPush seamless.
**Benefits:**
- Automatic subscription management
- No memory leaks
- Automatic change detection triggering
- Cleaner, more declarative templates
- Better performance with reactive patterns
**Implementation:** Use async pipe in templates for all Observable consumption, structure services to return Observables, and leverage reactive operators for data transformation.

---

### Slide: OnPush Best Practices and Common Pitfalls
#### Subtitle: Mastering OnPush for Production Applications
Successfully implementing OnPush requires understanding common pitfalls and following established best practices. Here are the key patterns for OnPush success.

**OnPush best practices:**
- Always use immutable update patterns for inputs
- Prefer async pipe over manual subscriptions
- Use ChangeDetectorRef judiciously for edge cases
- Implement proper trackBy functions for lists
- Avoid function calls in templates
- Test OnPush components thoroughly

**Comparison: OnPush Trade-offs:**
- **Before:** Default: Simple to use but can be inefficient with large component trees
- **After:** OnPush: Better performance but requires disciplined coding patterns and immutability

**Code Example: OnPush Best Practices and Pitfall Avoidance**
```typescript
// ✅ BEST PRACTICES

@Component({
  selector: 'app-onpush-best-practices',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="best-practices">
      <!-- ✅ Use async pipe for observables -->
      <div *ngIf="loading$ | async">Loading...</div>
      
      <!-- ✅ Use trackBy for performance -->
      <div *ngFor="let item of items$ | async; trackBy: trackByItemId">
        {{ item.name }}
      </div>
      
      <!-- ✅ Pre-computed values instead of functions -->
      <p>{{ formattedDate }}</p>
      
      <!-- ✅ Event handlers for user interactions -->
      <button (click)="handleClick()">Click Me</button>
    </div>
  `
})
export class OnPushBestPracticesComponent implements OnChanges {
  @Input() data!: ComplexData;
  @Input() items!: Item[];
  @Output() itemSelected = new EventEmitter<Item>();
  
  // ✅ Convert inputs to observables when needed
  items$ = new BehaviorSubject<Item[]>([]);
  loading$ = new BehaviorSubject<boolean>(false);
  
  // ✅ Pre-computed properties
  formattedDate = '';
  itemCount = 0;
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  ngOnChanges(changes: SimpleChanges) {
    // ✅ Handle input changes properly
    if (changes['items']) {
      this.items$.next(this.items);
      this.itemCount = this.items.length;
    }
    
    if (changes['data']) {
      this.formattedDate = this.data.date.toLocaleDateString();
      
      // ✅ Conditional change detection
      if (this.shouldUpdate(changes['data'])) {
        this.cdr.markForCheck();
      }
    }
  }
  
  // ✅ TrackBy function for performance
  trackByItemId(index: number, item: Item): number {
    return item.id;
  }
  
  // ✅ Event handlers trigger change detection
  handleClick() {
    this.itemSelected.emit(this.items[0]);
  }
  
  // ✅ Custom update logic
  private shouldUpdate(change: SimpleChange): boolean {
    const oldValue = change.previousValue;
    const newValue = change.currentValue;
    
    // Only update for significant changes
    return !oldValue || oldValue.version !== newValue.version;
  }
}

// ❌ COMMON PITFALLS TO AVOID

@Component({
  selector: 'app-onpush-pitfalls',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="pitfalls">
      <!-- ❌ Function calls in templates -->
      <p>{{ getFormattedDate() }}</p>
      
      <!-- ❌ No trackBy function -->
      <div *ngFor="let item of items">{{ item.name }}</div>
      
      <!-- ❌ Manual subscription without proper handling -->
      <p>{{ manualData }}</p>
    </div>
  `
})
export class OnPushPitfallsComponent implements OnInit, OnDestroy {
  @Input() items!: Item[];
  
  manualData = '';
  private subscription = new Subscription();
  
  constructor(
    private dataService: DataService,
    private cdr: ChangeDetectorRef
  ) {}
  
  ngOnInit() {
    // ❌ Manual subscription without proper change detection
    this.subscription.add(
      this.dataService.getData().subscribe(data => {
        this.manualData = data;
        // Forgot to call this.cdr.markForCheck()!
      })
    );
  }
  
  // ❌ Function in template - runs on every check
  getFormattedDate(): string {
    return new Date().toLocaleDateString();
  }
  
  // ❌ Mutating input - won't trigger change detection
  addItem(newItem: Item) {
    this.items.push(newItem); // Mutation!
  }
  
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}

// ✅ ADVANCED ONPUSH PATTERNS

@Component({
  selector: 'app-advanced-onpush',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="advanced">
      <!-- ✅ Conditional rendering with observables -->
      <ng-container *ngIf="viewModel$ | async as vm">
        <div [class.loading]="vm.loading">
          <h2>{{ vm.title }}</h2>
          <p>Items: {{ vm.items.length }}</p>
          
          <div *ngFor="let item of vm.items; trackBy: trackByItem">
            <item-component 
              [item]="item" 
              [selected]="vm.selectedId === item.id"
              (select)="selectItem(item.id)">
            </item-component>
          </div>
        </div>
      </ng-container>
    </div>
  `
})
export class AdvancedOnPushComponent implements OnInit {
  private selectedIdSubject = new BehaviorSubject<number | null>(null);
  private refreshSubject = new Subject<void>();
  
  // ✅ Single view model observable
  viewModel$: Observable<ViewModel>;
  
  constructor(private dataService: DataService) {}
  
  ngOnInit() {
    // ✅ Combine multiple streams into single view model
    this.viewModel$ = combineLatest([
      this.dataService.getItems(),
      this.dataService.loading$,
      this.selectedIdSubject.asObservable(),
      this.refreshSubject.pipe(startWith(null))
    ]).pipe(
      map(([items, loading, selectedId]) => ({
        title: 'Advanced OnPush Component',
        items,
        loading,
        selectedId
      })),
      shareReplay(1)
    );
  }
  
  selectItem(id: number) {
    this.selectedIdSubject.next(id);
  }
  
  refresh() {
    this.refreshSubject.next();
  }
  
  trackByItem(index: number, item: Item): number {
    return item.id;
  }
}

// ✅ OnPush with state management
@Component({
  selector: 'app-state-onpush',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <div *ngIf="user$ | async as user">
        <h2>{{ user.name }}</h2>
        <p>{{ user.email }}</p>
      </div>
      
      <div *ngFor="let todo of todos$ | async; trackBy: trackByTodoId">
        <todo-item 
          [todo]="todo" 
          (toggle)="toggleTodo(todo.id)"
          (delete)="deleteTodo(todo.id)">
        </todo-item>
      </div>
    </div>
  `
})
export class StateOnPushComponent {
  // ✅ State management with OnPush
  user$ = this.store.select(selectCurrentUser);
  todos$ = this.store.select(selectAllTodos);
  
  constructor(private store: Store) {}
  
  toggleTodo(id: number) {
    this.store.dispatch(toggleTodo({ id }));
  }
  
  deleteTodo(id: number) {
    this.store.dispatch(deleteTodo({ id }));
  }
  
  trackByTodoId(index: number, todo: Todo): number {
    return todo.id;
  }
}

// ✅ Testing OnPush components
describe('OnPushComponent', () => {
  let component: OnPushBestPracticesComponent;
  let fixture: ComponentFixture<OnPushBestPracticesComponent>;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [OnPushBestPracticesComponent]
    });
    
    fixture = TestBed.createComponent(OnPushBestPracticesComponent);
    component = fixture.componentInstance;
  });
  
  it('should update when input changes by reference', () => {
    const initialData = { id: 1, name: 'Test' };
    component.data = initialData;
    fixture.detectChanges();
    
    // ✅ Test immutable update
    const updatedData = { ...initialData, name: 'Updated' };
    component.data = updatedData;
    fixture.detectChanges();
    
    expect(component.formattedName).toBe('Updated');
  });
  
  it('should not update when input is mutated', () => {
    const data = { id: 1, name: 'Test' };
    component.data = data;
    fixture.detectChanges();
    
    // ❌ Mutation won't trigger OnPush
    data.name = 'Mutated';
    fixture.detectChanges();
    
    expect(component.formattedName).toBe('Test'); // Still old value
  });
});
```
**Explanation:** Following OnPush best practices ensures reliable, performant components. Avoid common pitfalls like function calls in templates and object mutations.

**Problem:** OnPush components can be tricky to implement correctly, with common pitfalls leading to components that don't update when expected or perform poorly.
**Solution:** Following established best practices and avoiding common pitfalls ensures OnPush components work reliably and provide the expected performance benefits.
**Benefits:**
- Reliable component update behavior
- Maximum performance benefits
- Easier debugging and maintenance
- Better integration with reactive patterns
- Improved application scalability
**Implementation:** Use immutable patterns, async pipe, proper trackBy functions, avoid template function calls, and test OnPush behavior thoroughly.

---## Part 4: The Revolution (Signals) - Fine-Grained Reactive "Push" Model

### Slide: Part 4: The Revolution (Signals)
#### Subtitle: Fine-Grained Reactive "Push" Model
Signals represent a fundamental shift in Angular's reactivity model. Instead of Angular asking "has anything changed?", signals push notifications when they change, creating a fine-grained reactive system.

**Highlight:** Signals flip the model from "pull-based" change detection to "push-based" reactivity, creating a dependency graph independent of the component tree.

**Problems signals solve:**
- Zone.js complexity and performance overhead
- OnPush requires careful immutability management
- Difficulty tracking reactive dependencies
- Pull-based model checks everything unnecessarily
- Complex state management patterns
- Debugging reactive flows is challenging

**Code Example: Signals vs Traditional Approach**
```typescript
// ❌ Traditional approach with Zone.js + OnPush
@Component({
  selector: 'app-traditional',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <h2>{{ user.name }}</h2>
      <p>Posts: {{ user.posts.length }}</p>
      <p>Status: {{ userStatus }}</p>
      <p>Last update: {{ lastUpdate | date:'medium' }}</p>
    </div>
  `
})
export class TraditionalComponent implements OnChanges {
  @Input() user!: User;
  
  userStatus = '';
  lastUpdate = new Date();
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  ngOnChanges(changes: SimpleChanges) {
    if (changes['user']) {
      // Manual computation on input change
      this.userStatus = this.user.isActive ? 'Active' : 'Inactive';
      this.lastUpdate = new Date();
      
      // Manual change detection trigger
      this.cdr.markForCheck();
    }
  }
  
  updateUser(updates: Partial<User>) {
    // Must create new reference for OnPush
    this.user = { ...this.user, ...updates };
    this.userStatus = this.user.isActive ? 'Active' : 'Inactive';
    this.lastUpdate = new Date();
  }
}

// ✅ Modern approach with Signals
@Component({
  selector: 'app-signals',
  template: `
    <div>
      <h2>{{ user().name }}</h2>
      <p>Posts: {{ user().posts.length }}</p>
      <p>Status: {{ userStatus() }}</p>
      <p>Last update: {{ lastUpdate() | date:'medium' }}</p>
    </div>
  `
})
export class SignalsComponent {
  // Signal input - automatically reactive
  user = input.required<User>();
  
  // Computed signals - automatically update when dependencies change
  userStatus = computed(() => 
    this.user().isActive ? 'Active' : 'Inactive'
  );
  
  lastUpdate = computed(() => {
    // Depends on user signal - updates automatically
    this.user(); // Read to create dependency
    return new Date();
  });
  
  // Effects for side effects
  constructor() {
    effect(() => {
      console.log(`User ${this.user().name} status changed to ${this.userStatus()}`);
    });
  }
  
  updateUser(updates: Partial<User>) {
    // Direct signal update - all dependents update automatically
    this.user.set({ ...this.user(), ...updates });
    // No manual change detection needed!
    // userStatus() and lastUpdate() update automatically!
  }
}

// The key differences:
// 1. No ChangeDetectionStrategy.OnPush needed
// 2. No manual change detection triggering
// 3. No ngOnChanges lifecycle
// 4. Automatic dependency tracking
// 5. Computed values update automatically
// 6. Effects run when dependencies change
```
**Explanation:** Signals eliminate the complexity of manual change detection and immutability management while providing automatic dependency tracking and updates.

**Problem:** Traditional change detection is pull-based, checking everything on every cycle, while OnPush requires complex immutability patterns and manual triggering.
**Solution:** Signals provide a push-based reactive system with automatic dependency tracking, eliminating the need for manual change detection and immutability management.
**Benefits:**
- Automatic dependency tracking
- Fine-grained reactivity
- No manual change detection needed
- Simplified state management
- Better performance characteristics
- Clearer reactive relationships
**Implementation:** Use signal(), computed(), and effect() to create reactive data flows that automatically update when dependencies change.

---

### Slide: Signals Fundamentals: signal(), computed(), effect()
#### Subtitle: The Building Blocks of Reactive Programming
Signals provide three fundamental primitives: signal() for writable state, computed() for derived values, and effect() for side effects. Understanding these building blocks is essential for reactive programming.

**Core signal primitives:**
- signal(initialValue) - Creates writable reactive state
- computed(() => ...) - Creates derived read-only values
- effect(() => ...) - Executes side effects when dependencies change
- Automatic dependency tracking across all primitives
- Lazy evaluation and memoization for performance
- Glitch-free updates with topological sorting

**Highlight:** Signals use automatic dependency tracking - any signal read inside computed() or effect() becomes a dependency.

**Code Example: Complete Signals API Guide**
```typescript
@Component({
  selector: 'app-signals-fundamentals',
  template: `
    <div class="signals-demo">
      <!-- Reading signals in templates -->
      <h2>{{ title() }}</h2>
      <p>Count: {{ count() }}</p>
      <p>Double: {{ doubled() }}</p>
      <p>Status: {{ status() }}</p>
      <p>History: {{ history().join(', ') }}</p>
      
      <!-- Signal updates through events -->
      <button (click)="increment()">Increment</button>
      <button (click)="decrement()">Decrement</button>
      <button (click)="reset()">Reset</button>
      <button (click)="setRandom()">Random</button>
    </div>
  `
})
export class SignalsFundamentalsComponent {
  // ✅ 1. WRITABLE SIGNALS
  
  // Basic signal with initial value
  count = signal(0);
  title = signal('Signals Demo');
  
  // Signal with complex data
  user = signal({
    name: 'John',
    email: 'john@example.com',
    preferences: { theme: 'dark', notifications: true }
  });
  
  // Array signal
  history = signal<number[]>([]);
  
  // ✅ 2. COMPUTED SIGNALS (Derived State)
  
  // Simple computed - automatically updates when count changes
  doubled = computed(() => this.count() * 2);
  
  // Complex computed with multiple dependencies
  status = computed(() => {
    const currentCount = this.count();
    const currentHistory = this.history();
    
    if (currentCount === 0) return 'Zero';
    if (currentCount > 0) return 'Positive';
    return 'Negative';
  });
  
  // Computed with conditional logic
  summary = computed(() => {
    const count = this.count();
    const doubled = this.doubled(); // Can depend on other computed signals
    const historyLength = this.history().length;
    
    return `Count: ${count}, Doubled: ${doubled}, History: ${historyLength} items`;
  });
  
  // Expensive computed - only recalculates when dependencies change
  expensiveCalculation = computed(() => {
    console.log('Expensive calculation running...'); // Only logs when count changes
    const count = this.count();
    
    // Simulate expensive operation
    let result = 0;
    for (let i = 0; i < count * 1000; i++) {
      result += Math.sqrt(i);
    }
    return result;
  });
  
  // ✅ 3. EFFECTS (Side Effects)
  
  constructor() {
    // Basic effect - runs when count changes
    effect(() => {
      console.log(`Count changed to: ${this.count()}`);
    });
    
    // Effect with multiple dependencies
    effect(() => {
      const count = this.count();
      const status = this.status();
      console.log(`Status update: ${status} (count: ${count})`);
    });
    
    // Effect with cleanup
    effect((onCleanup) => {
      const count = this.count();
      
      if (count > 10) {
        const timer = setInterval(() => {
          console.log('High count detected!');
        }, 1000);
        
        // Cleanup function - called when effect re-runs or component destroys
        onCleanup(() => {
          clearInterval(timer);
          console.log('Timer cleaned up');
        });
      }
    });
    
    // Conditional effect
    effect(() => {
      const user = this.user();
      
      if (user.preferences.notifications) {
        console.log(`Notifications enabled for ${user.name}`);
        // Setup notification listener
      }
    });
  }
  
  // ✅ 4. SIGNAL UPDATES
  
  // .set() - Replace entire value
  increment() {
    this.count.set(this.count() + 1);
    
    // Update history array
    this.history.set([...this.history(), this.count()]);
  }
  
  decrement() {
    this.count.set(this.count() - 1);
    this.history.set([...this.history(), this.count()]);
  }
  
  // .update() - Transform current value
  reset() {
    this.count.update(() => 0);
    this.history.update(hist => [...hist, 0]);
  }
  
  setRandom() {
    this.count.update(() => Math.floor(Math.random() * 100));
    this.history.update(hist => [...hist, this.count()]);
  }
  
  // Complex object updates
  updateUserName(newName: string) {
    this.user.update(currentUser => ({
      ...currentUser,
      name: newName
    }));
  }
  
  toggleNotifications() {
    this.user.update(currentUser => ({
      ...currentUser,
      preferences: {
        ...currentUser.preferences,
        notifications: !currentUser.preferences.notifications
      }
    }));
  }
  
  // ✅ 5. ADVANCED PATTERNS
  
  // Derived signals from other signals
  createDerivedSignals() {
    // Chain computed signals
    const base = signal(10);
    const doubled = computed(() => base() * 2);
    const quadrupled = computed(() => doubled() * 2);
    const formatted = computed(() => `Value: ${quadrupled()}`);
    
    return { base, doubled, quadrupled, formatted };
  }
  
  // Signal composition
  createComposedSignal() {
    const firstName = signal('John');
    const lastName = signal('Doe');
    const fullName = computed(() => `${firstName()} ${lastName()}`);
    
    return { firstName, lastName, fullName };
  }
  
  // Conditional computed
  createConditionalComputed() {
    const showDetails = signal(false);
    const details = signal({ age: 30, city: 'New York' });
    
    const displayText = computed(() => {
      if (!showDetails()) return 'Details hidden';
      
      const { age, city } = details();
      return `Age: ${age}, City: ${city}`;
    });
    
    return { showDetails, details, displayText };
  }
}

// ✅ SIGNALS WITH SERVICES

@Injectable()
export class SignalsService {
  // Private writable signals
  private _users = signal<User[]>([]);
  private _loading = signal(false);
  private _error = signal<string | null>(null);
  
  // Public readonly signals
  users = this._users.asReadonly();
  loading = this._loading.asReadonly();
  error = this._error.asReadonly();
  
  // Computed signals
  userCount = computed(() => this._users().length);
  activeUsers = computed(() => this._users().filter(u => u.isActive));
  usersByDepartment = computed(() => {
    const users = this._users();
    const groups = new Map<string, User[]>();
    
    users.forEach(user => {
      const dept = user.department;
      if (!groups.has(dept)) groups.set(dept, []);
      groups.get(dept)!.push(user);
    });
    
    return groups;
  });
  
  constructor(private http: HttpClient) {}
  
  async loadUsers() {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const users = await this.http.get<User[]>('/api/users').toPromise();
      this._users.set(users || []);
    } catch (error) {
      this._error.set(error instanceof Error ? error.message : 'Unknown error');
    } finally {
      this._loading.set(false);
    }
  }
  
  addUser(user: User) {
    this._users.update(users => [...users, user]);
  }
  
  updateUser(id: number, updates: Partial<User>) {
    this._users.update(users =>
      users.map(user => user.id === id ? { ...user, ...updates } : user)
    );
  }
  
  removeUser(id: number) {
    this._users.update(users => users.filter(user => user.id !== id));
  }
}
```
**Explanation:** Signals provide automatic dependency tracking, lazy evaluation, and memoization. Computed signals only recalculate when their dependencies change, and effects run automatically when dependencies update.

**Problem:** Traditional reactive programming requires manual dependency management, subscription handling, and change detection triggering.
**Solution:** Signals provide automatic dependency tracking with signal(), computed(), and effect() primitives that handle reactivity transparently.
**Benefits:**
- Automatic dependency tracking
- Lazy evaluation and memoization
- No manual subscription management
- Glitch-free updates
- Clear reactive relationships
- Better performance characteristics
**Implementation:** Use signal() for state, computed() for derived values, and effect() for side effects. Dependencies are tracked automatically when signals are read.

---

### Slide: Signal Inputs and Queries: The New Component API
#### Subtitle: Modern Angular Component Architecture
Angular 17+ introduces signal-based inputs and queries, providing a more reactive and type-safe way to handle component inputs and DOM queries.

**New signal-based APIs:**
- input() - Signal-based component inputs
- input.required() - Required signal inputs
- model() - Two-way binding with signals
- viewChild() - Signal-based view queries
- viewChildren() - Signal-based view children queries
- contentChild() / contentChildren() - Signal-based content queries

**Highlight:** Signal inputs and queries are automatically reactive and integrate seamlessly with computed signals and effects.

**Code Example: Signal Inputs and Queries Complete Guide**
```typescript
// ✅ SIGNAL INPUTS

@Component({
  selector: 'app-user-profile',
  template: `
    <div class="user-profile">
      <h2>{{ displayName() }}</h2>
      <p>{{ user().email }}</p>
      <p>Theme: {{ user().preferences?.theme || 'default' }}</p>
      <p>Age Category: {{ ageCategory() }}</p>
      
      <!-- Optional inputs with defaults -->
      <div [class]="theme()">
        <p>Show details: {{ showDetails() }}</p>
      </div>
      
      <!-- Two-way binding with model -->
      <input [(ngModel)]="searchTerm" placeholder="Search...">
      <p>Searching for: {{ searchTerm() }}</p>
      
      <!-- Template reference for viewChild -->
      <div #container class="container">
        <input #nameInput [value]="user().name" (input)="updateName($event)">
        <button #submitBtn (click)="save()">Save</button>
      </div>
      
      <!-- Multiple elements for viewChildren -->
      <div class="buttons">
        <button #actionBtn *ngFor="let action of actions" (click)="executeAction(action)">
          {{ action }}
        </button>
      </div>
    </div>
  `
})
export class UserProfileComponent implements AfterViewInit {
  // ✅ REQUIRED SIGNAL INPUTS
  user = input.required<User>(); // Must be provided by parent
  
  // ✅ OPTIONAL SIGNAL INPUTS WITH DEFAULTS
  theme = input<string>('light'); // Default value
  showDetails = input<boolean>(false);
  maxAge = input<number>(100);
  
  // ✅ SIGNAL INPUTS WITH TRANSFORMATION
  userId = input<number, string>(0, {
    transform: (value: string) => parseInt(value, 10)
  });
  
  // ✅ TWO-WAY BINDING WITH MODEL
  searchTerm = model<string>(''); // Creates input + output automatically
  
  // ✅ COMPUTED SIGNALS FROM INPUTS
  displayName = computed(() => {
    const user = this.user();
    const details = this.showDetails();
    return details ? `${user.name} (${user.email})` : user.name;
  });
  
  ageCategory = computed(() => {
    const age = this.user().age;
    const maxAge = this.maxAge();
    
    if (age < 18) return 'Minor';
    if (age < 65) return 'Adult';
    if (age <= maxAge) return 'Senior';
    return 'Ancient';
  });
  
  // ✅ SIGNAL VIEW QUERIES
  container = viewChild<ElementRef>('container'); // Single element
  nameInput = viewChild<ElementRef>('nameInput');
  submitBtn = viewChild<ElementRef>('submitBtn');
  
  // ✅ SIGNAL VIEW CHILDREN QUERIES
  actionButtons = viewChildren<ElementRef>('actionBtn'); // Multiple elements
  
  // ✅ SIGNAL CONTENT QUERIES
  customContent = contentChild<TemplateRef>('customTemplate');
  allContent = contentChildren<ElementRef>('contentItem');
  
  actions = ['Save', 'Cancel', 'Delete'];
  
  constructor() {
    // ✅ EFFECTS WITH SIGNAL INPUTS
    effect(() => {
      console.log(`User changed: ${this.user().name}`);
      console.log(`Theme: ${this.theme()}`);
    });
    
    // Effect with input validation
    effect(() => {
      const user = this.user();
      if (!user.email.includes('@')) {
        console.warn('Invalid email format');
      }
    });
    
    // Effect with search term
    effect(() => {
      const term = this.searchTerm();
      if (term.length > 2) {
        console.log(`Searching for: ${term}`);
        this.performSearch(term);
      }
    });
  }
  
  ngAfterViewInit() {
    // ✅ SIGNAL QUERIES ARE AVAILABLE IMMEDIATELY
    effect(() => {
      const container = this.container();
      if (container) {
        console.log('Container element:', container.nativeElement);
      }
    });
    
    effect(() => {
      const buttons = this.actionButtons();
      console.log(`Found ${buttons.length} action buttons`);
    });
    
    // Focus input when component loads
    effect(() => {
      const input = this.nameInput();
      if (input) {
        input.nativeElement.focus();
      }
    });
  }
  
  updateName(event: Event) {
    const target = event.target as HTMLInputElement;
    // Update parent through output (handled by framework)
    // Or emit custom event
  }
  
  save() {
    const user = this.user();
    console.log('Saving user:', user);
  }
  
  executeAction(action: string) {
    console.log(`Executing action: ${action}`);
  }
  
  private performSearch(term: string) {
    // Implement search logic
  }
}

// ✅ PARENT COMPONENT USING SIGNAL INPUTS

@Component({
  selector: 'app-parent',
  template: `
    <div>
      <h1>Parent Component</h1>
      
      <!-- Signal inputs binding -->
      <app-user-profile
        [user]="currentUser()"
        [theme]="selectedTheme()"
        [showDetails]="showUserDetails()"
        [(searchTerm)]="globalSearchTerm"
      ></app-user-profile>
      
      <!-- Controls -->
      <div class="controls">
        <button (click)="toggleDetails()">Toggle Details</button>
        <button (click)="switchTheme()">Switch Theme</button>
        <button (click)="updateUser()">Update User</button>
      </div>
      
      <p>Global search: {{ globalSearchTerm() }}</p>
    </div>
  `
})
export class ParentComponent {
  // Parent signals
  currentUser = signal<User>({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    age: 30,
    preferences: { theme: 'dark' }
  });
  
  selectedTheme = signal<string>('light');
  showUserDetails = signal<boolean>(false);
  globalSearchTerm = model<string>('');
  
  toggleDetails() {
    this.showUserDetails.update(show => !show);
  }
  
  switchTheme() {
    this.selectedTheme.update(theme => theme === 'light' ? 'dark' : 'light');
  }
  
  updateUser() {
    this.currentUser.update(user => ({
      ...user,
      name: 'Jane Doe',
      age: user.age + 1
    }));
  }
}

// ✅ ADVANCED SIGNAL QUERIES PATTERNS

@Component({
  selector: 'app-advanced-queries',
  template: `
    <div>
      <!-- Dynamic content -->
      <div *ngFor="let item of items(); trackBy: trackByItem">
        <div #itemElement [attr.data-id]="item.id">{{ item.name }}</div>
      </div>
      
      <!-- Conditional content -->
      <div *ngIf="showModal()" #modal class="modal">
        <p>Modal content</p>
      </div>
    </div>
  `
})
export class AdvancedQueriesComponent {
  items = signal([
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' }
  ]);
  
  showModal = signal(false);
  
  // Query all item elements
  itemElements = viewChildren<ElementRef>('itemElement');
  
  // Query modal (may not exist)
  modal = viewChild<ElementRef>('modal');
  
  constructor() {
    // React to query changes
    effect(() => {
      const elements = this.itemElements();
      console.log(`Found ${elements.length} item elements`);
      
      // Apply styles or behavior to elements
      elements.forEach((el, index) => {
        el.nativeElement.style.animationDelay = `${index * 100}ms`;
      });
    });
    
    // React to modal visibility
    effect(() => {
      const modalEl = this.modal();
      if (modalEl) {
        console.log('Modal is now visible');
        modalEl.nativeElement.focus();
      }
    });
  }
  
  trackByItem(index: number, item: any): number {
    return item.id;
  }
  
  addItem() {
    const newId = Math.max(...this.items().map(i => i.id)) + 1;
    this.items.update(items => [...items, { id: newId, name: `Item ${newId}` }]);
  }
  
  toggleModal() {
    this.showModal.update(show => !show);
  }
}
```
**Explanation:** Signal inputs and queries provide automatic reactivity and type safety. They integrate seamlessly with computed signals and effects for powerful reactive patterns.

**Problem:** Traditional @Input decorators and ViewChild queries are not reactive and require lifecycle hooks for proper handling.
**Solution:** Signal inputs and queries provide automatic reactivity, type safety, and seamless integration with the signals ecosystem.
**Benefits:**
- Automatic reactivity for inputs and queries
- Better type safety and IntelliSense
- No lifecycle hooks needed
- Seamless integration with computed and effects
- Cleaner, more declarative code
**Implementation:** Replace @Input with input(), @ViewChild with viewChild(), and use computed() and effect() to react to changes automatically.

---

### Slide: Signals for State Management
#### Subtitle: Building Reactive Applications with Signals
Signals provide a powerful foundation for state management, enabling reactive patterns that are simpler and more performant than traditional approaches.

**Signals state management benefits:**
- Fine-grained reactivity without subscriptions
- Automatic dependency tracking across components
- No need for complex state management libraries
- Built-in memoization and performance optimization
- Type-safe reactive programming
- Simplified testing and debugging

**Comparison: State Management Approaches:**
- **Before:** Traditional: Complex state libraries, subscriptions, manual change detection
- **After:** Signals: Built-in reactivity, automatic updates, simplified patterns

**Code Example: Complete Signals State Management Example**
```typescript
// ✅ SIGNALS-BASED STATE MANAGEMENT

// State service with signals
@Injectable({
  providedIn: 'root'
})
export class TodoStateService {
  // Private writable signals
  private _todos = signal<Todo[]>([]);
  private _filter = signal<'all' | 'active' | 'completed'>('all');
  private _loading = signal(false);
  private _error = signal<string | null>(null);
  
  // Public readonly signals
  todos = this._todos.asReadonly();
  filter = this._filter.asReadonly();
  loading = this._loading.asReadonly();
  error = this._error.asReadonly();
  
  // Computed state (derived signals)
  filteredTodos = computed(() => {
    const todos = this._todos();
    const filter = this._filter();
    
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  });
  
  activeTodosCount = computed(() => 
    this._todos().filter(todo => !todo.completed).length
  );
  
  completedTodosCount = computed(() => 
    this._todos().filter(todo => todo.completed).length
  );
  
  allCompleted = computed(() => 
    this._todos().length > 0 && this._todos().every(todo => todo.completed)
  );
  
  hasActiveTodos = computed(() => this.activeTodosCount() > 0);
  
  // Statistics
  statistics = computed(() => {
    const todos = this._todos();
    const total = todos.length;
    const active = this.activeTodosCount();
    const completed = this.completedTodosCount();
    
    return {
      total,
      active,
      completed,
      completionRate: total > 0 ? Math.round((completed / total) * 100) : 0
    };
  });
  
  constructor(private http: HttpClient) {
    // Load initial data
    this.loadTodos();
    
    // Auto-save effect
    effect(() => {
      const todos = this._todos();
      if (todos.length > 0) {
        this.autoSave(todos);
      }
    });
  }
  
  // Actions (state mutations)
  async loadTodos() {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const todos = await this.http.get<Todo[]>('/api/todos').toPromise();
      this._todos.set(todos || []);
    } catch (error) {
      this._error.set(error instanceof Error ? error.message : 'Failed to load todos');
    } finally {
      this._loading.set(false);
    }
  }
  
  addTodo(text: string) {
    const newTodo: Todo = {
      id: Date.now(),
      text: text.trim(),
      completed: false,
      createdAt: new Date()
    };
    
    this._todos.update(todos => [...todos, newTodo]);
  }
  
  toggleTodo(id: number) {
    this._todos.update(todos =>
      todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }
  
  updateTodoText(id: number, text: string) {
    this._todos.update(todos =>
      todos.map(todo =>
        todo.id === id ? { ...todo, text: text.trim() } : todo
      )
    );
  }
  
  deleteTodo(id: number) {
    this._todos.update(todos => todos.filter(todo => todo.id !== id));
  }
  
  clearCompleted() {
    this._todos.update(todos => todos.filter(todo => !todo.completed));
  }
  
  toggleAll() {
    const allCompleted = this.allCompleted();
    this._todos.update(todos =>
      todos.map(todo => ({ ...todo, completed: !allCompleted }))
    );
  }
  
  setFilter(filter: 'all' | 'active' | 'completed') {
    this._filter.set(filter);
  }
  
  private autoSave(todos: Todo[]) {
    // Debounced auto-save logic
    localStorage.setItem('todos', JSON.stringify(todos));
  }
}

// ✅ COMPONENT USING SIGNALS STATE

@Component({
  selector: 'app-todo-list',
  template: `
    <div class="todo-app">
      <header class="header">
        <h1>Todos</h1>
        <input
          #newTodoInput
          class="new-todo"
          placeholder="What needs to be done?"
          (keyup.enter)="addTodo(newTodoInput.value); newTodoInput.value = ''"
          [disabled]="todoState.loading()"
        >
      </header>
      
      <main class="main" *ngIf="todoState.todos().length > 0">
        <input
          #toggleAll
          class="toggle-all"
          type="checkbox"
          [checked]="todoState.allCompleted()"
          (change)="todoState.toggleAll()"
        >
        <label for="toggle-all">Mark all as complete</label>
        
        <ul class="todo-list">
          <li
            *ngFor="let todo of todoState.filteredTodos(); trackBy: trackByTodoId"
            [class.completed]="todo.completed"
            [class.editing]="editingTodoId() === todo.id"
          >
            <div class="view">
              <input
                class="toggle"
                type="checkbox"
                [checked]="todo.completed"
                (change)="todoState.toggleTodo(todo.id)"
              >
              <label (dblclick)="startEditing(todo.id)">{{ todo.text }}</label>
              <button class="destroy" (click)="todoState.deleteTodo(todo.id)"></button>
            </div>
            <input
              *ngIf="editingTodoId() === todo.id"
              #editInput
              class="edit"
              [value]="todo.text"
              (blur)="finishEditing(todo.id, editInput.value)"
              (keyup.enter)="finishEditing(todo.id, editInput.value)"
              (keyup.escape)="cancelEditing()"
            >
          </li>
        </ul>
      </main>
      
      <footer class="footer" *ngIf="todoState.todos().length > 0">
        <span class="todo-count">
          <strong>{{ todoState.activeTodosCount() }}</strong>
          {{ todoState.activeTodosCount() === 1 ? 'item' : 'items' }} left
        </span>
        
        <ul class="filters">
          <li>
            <a
              [class.selected]="todoState.filter() === 'all'"
              (click)="todoState.setFilter('all')"
            >All</a>
          </li>
          <li>
            <a
              [class.selected]="todoState.filter() === 'active'"
              (click)="todoState.setFilter('active')"
            >Active</a>
          </li>
          <li>
            <a
              [class.selected]="todoState.filter() === 'completed'"
              (click)="todoState.setFilter('completed')"
            >Completed</a>
          </li>
        </ul>
        
        <button
          class="clear-completed"
          *ngIf="todoState.completedTodosCount() > 0"
          (click)="todoState.clearCompleted()"
        >
          Clear completed
        </button>
      </footer>
      
      <!-- Statistics -->
      <div class="statistics" *ngIf="todoState.statistics() as stats">
        <p>Total: {{ stats.total }}</p>
        <p>Active: {{ stats.active }}</p>
        <p>Completed: {{ stats.completed }}</p>
        <p>Completion Rate: {{ stats.completionRate }}%</p>
      </div>
      
      <!-- Loading and Error States -->
      <div *ngIf="todoState.loading()" class="loading">Loading todos...</div>
      <div *ngIf="todoState.error() as error" class="error">{{ error }}</div>
    </div>
  `
})
export class TodoListComponent {
  editingTodoId = signal<number | null>(null);
  
  constructor(public todoState: TodoStateService) {
    // Effects for side effects
    effect(() => {
      const stats = this.todoState.statistics();
      console.log('Todo statistics updated:', stats);
    });
    
    // Effect for notifications
    effect(() => {
      const completionRate = this.todoState.statistics().completionRate;
      if (completionRate === 100 && this.todoState.todos().length > 0) {
        console.log('🎉 All todos completed!');
      }
    });
  }
  
  addTodo(text: string) {
    if (text.trim()) {
      this.todoState.addTodo(text);
    }
  }
  
  startEditing(id: number) {
    this.editingTodoId.set(id);
  }
  
  finishEditing(id: number, text: string) {
    if (text.trim()) {
      this.todoState.updateTodoText(id, text);
    } else {
      this.todoState.deleteTodo(id);
    }
    this.editingTodoId.set(null);
  }
  
  cancelEditing() {
    this.editingTodoId.set(null);
  }
  
  trackByTodoId(index: number, todo: Todo): number {
    return todo.id;
  }
}

// ✅ GLOBAL STATE WITH SIGNALS

@Injectable({
  providedIn: 'root'
})
export class AppStateService {
  // User state
  private _currentUser = signal<User | null>(null);
  private _isAuthenticated = signal(false);
  
  // UI state
  private _theme = signal<'light' | 'dark'>('light');
  private _sidebarOpen = signal(false);
  private _notifications = signal<Notification[]>([]);
  
  // Public readonly signals
  currentUser = this._currentUser.asReadonly();
  isAuthenticated = this._isAuthenticated.asReadonly();
  theme = this._theme.asReadonly();
  sidebarOpen = this._sidebarOpen.asReadonly();
  notifications = this._notifications.asReadonly();
  
  // Computed global state
  unreadNotifications = computed(() =>
    this._notifications().filter(n => !n.read).length
  );
  
  userDisplayName = computed(() => {
    const user = this._currentUser();
    return user ? `${user.firstName} ${user.lastName}` : 'Guest';
  });
  
  constructor() {
    // Persist theme changes
    effect(() => {
      localStorage.setItem('theme', this.theme());
      document.body.className = this.theme();
    });
    
    // Load persisted state
    this.loadPersistedState();
  }
  
  // Actions
  login(user: User) {
    this._currentUser.set(user);
    this._isAuthenticated.set(true);
  }
  
  logout() {
    this._currentUser.set(null);
    this._isAuthenticated.set(false);
  }
  
  toggleTheme() {
    this._theme.update(theme => theme === 'light' ? 'dark' : 'light');
  }
  
  toggleSidebar() {
    this._sidebarOpen.update(open => !open);
  }
  
  addNotification(notification: Omit<Notification, 'id' | 'timestamp'>) {
    const newNotification: Notification = {
      ...notification,
      id: Date.now(),
      timestamp: new Date(),
      read: false
    };
    
    this._notifications.update(notifications => [newNotification, ...notifications]);
  }
  
  markNotificationAsRead(id: number) {
    this._notifications.update(notifications =>
      notifications.map(n => n.id === id ? { ...n, read: true } : n)
    );
  }
  
  private loadPersistedState() {
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark';
    if (savedTheme) {
      this._theme.set(savedTheme);
    }
  }
}
```
**Explanation:** Signals provide a complete state management solution with automatic reactivity, computed state, and effects for side effects, eliminating the need for complex state libraries.

**Problem:** Traditional state management requires complex libraries, manual subscriptions, and careful change detection management.
**Solution:** Signals provide built-in reactive state management with automatic dependency tracking, computed state, and effects for side effects.
**Benefits:**
- No external state management library needed
- Automatic reactivity and updates
- Built-in performance optimizations
- Type-safe reactive programming
- Simplified testing and debugging
- Fine-grained reactivity
**Implementation:** Use services with private writable signals and public readonly signals, computed for derived state, and effects for side effects.

---

### Slide: Migration Strategy: From Traditional to Signals
#### Subtitle: Practical Steps for Adopting Signals
Migrating from traditional Angular patterns to signals requires a strategic approach. Here's a practical guide for incrementally adopting signals in existing applications.

**Migration strategy steps:**
- 1. Start with new components using signal inputs
- 2. Convert simple @Input properties to input()
- 3. Replace ViewChild queries with viewChild()
- 4. Migrate computed properties to computed()
- 5. Convert services to use signals for state
- 6. Replace RxJS subscriptions with effects

**Highlight:** Signals are fully interoperable with existing Angular patterns, allowing for gradual migration without breaking changes.

**Code Example: Step-by-Step Migration Guide**
```typescript
// ❌ BEFORE: Traditional Angular Component
@Component({
  selector: 'app-user-card-old',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="user-card">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <p>Status: {{ userStatus }}</p>
      <p>Posts: {{ user.posts.length }}</p>
      <button #editBtn (click)="edit()">Edit</button>
    </div>
  `
})
export class UserCardOldComponent implements OnInit, OnChanges, OnDestroy {
  @Input() user!: User;
  @Input() showDetails = false;
  @Output() userEdit = new EventEmitter<User>();
  
  @ViewChild('editBtn') editButton!: ElementRef;
  
  userStatus = '';
  private subscription = new Subscription();
  
  constructor(
    private userService: UserService,
    private cdr: ChangeDetectorRef
  ) {}
  
  ngOnInit() {
    this.subscription.add(
      this.userService.getUserStatus(this.user.id).subscribe(status => {
        this.userStatus = status;
        this.cdr.markForCheck();
      })
    );
  }
  
  ngOnChanges(changes: SimpleChanges) {
    if (changes['user']) {
      this.updateUserStatus();
    }
  }
  
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  
  private updateUserStatus() {
    this.userStatus = this.user.isActive ? 'Active' : 'Inactive';
  }
  
  edit() {
    this.userEdit.emit(this.user);
  }
}

// ✅ AFTER: Signals-Based Component
@Component({
  selector: 'app-user-card-new',
  template: `
    <div class="user-card">
      <h3>{{ user().name }}</h3>
      <p>{{ user().email }}</p>
      <p>Status: {{ userStatus() }}</p>
      <p>Posts: {{ user().posts.length }}</p>
      @if (showDetails()) {
        <div class="details">
          <p>Created: {{ user().createdAt | date }}</p>
          <p>Last login: {{ user().lastLogin | date }}</p>
        </div>
      }
      <button #editBtn (click)="edit()">Edit</button>
    </div>
  `
})
export class UserCardNewComponent {
  // ✅ Step 1: Convert @Input to input()
  user = input.required<User>();
  showDetails = input<boolean>(false);
  
  // ✅ Step 2: Convert @Output (still works the same)
  @Output() userEdit = new EventEmitter<User>();
  
  // ✅ Step 3: Convert @ViewChild to viewChild()
  editButton = viewChild<ElementRef>('editBtn');
  
  // ✅ Step 4: Convert computed properties to computed()
  userStatus = computed(() => 
    this.user().isActive ? 'Active' : 'Inactive'
  );
  
  constructor(private userService: UserService) {
    // ✅ Step 5: Replace subscriptions with effects
    effect(() => {
      const userId = this.user().id;
      console.log(`User changed: ${userId}`);
      // Effects can handle async operations too
    });
    
    // ✅ Step 6: Effect for view child access
    effect(() => {
      const button = this.editButton();
      if (button) {
        console.log('Edit button available');
      }
    });
  }
  
  edit() {
    this.userEdit.emit(this.user());
  }
}

// ✅ MIGRATION STRATEGY FOR SERVICES

// ❌ BEFORE: Traditional RxJS Service
@Injectable()
export class UserServiceOld {
  private usersSubject = new BehaviorSubject<User[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  
  users$ = this.usersSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  
  activeUsers$ = this.users$.pipe(
    map(users => users.filter(u => u.isActive))
  );
  
  constructor(private http: HttpClient) {}
  
  loadUsers() {
    this.loadingSubject.next(true);
    this.http.get<User[]>('/api/users').subscribe({
      next: users => {
        this.usersSubject.next(users);
        this.loadingSubject.next(false);
      },
      error: () => this.loadingSubject.next(false)
    });
  }
  
  addUser(user: User) {
    const currentUsers = this.usersSubject.value;
    this.usersSubject.next([...currentUsers, user]);
  }
}

// ✅ AFTER: Signals-Based Service
@Injectable()
export class UserServiceNew {
  // ✅ Step 1: Convert BehaviorSubjects to signals
  private _users = signal<User[]>([]);
  private _loading = signal<boolean>(false);
  
  // ✅ Step 2: Expose readonly signals
  users = this._users.asReadonly();
  loading = this._loading.asReadonly();
  
  // ✅ Step 3: Convert derived observables to computed
  activeUsers = computed(() => 
    this._users().filter(u => u.isActive)
  );
  
  constructor(private http: HttpClient) {}
  
  // ✅ Step 4: Update methods to use signals
  async loadUsers() {
    this._loading.set(true);
    try {
      const users = await this.http.get<User[]>('/api/users').toPromise();
      this._users.set(users || []);
    } finally {
      this._loading.set(false);
    }
  }
  
  addUser(user: User) {
    this._users.update(users => [...users, user]);
  }
}

// ✅ INTEROPERABILITY: Mixing Signals and Observables

@Component({
  selector: 'app-mixed-approach',
  template: `
    <div>
      <!-- Signals in template -->
      <h2>{{ title() }}</h2>
      <p>Count: {{ count() }}</p>
      
      <!-- Observables with async pipe -->
      <p>Data: {{ data$ | async }}</p>
      
      <!-- Mixed reactive patterns -->
      <p>Combined: {{ combinedValue() }}</p>
    </div>
  `
})
export class MixedApproachComponent implements OnInit {
  // Signals
  title = signal('Mixed Approach');
  count = signal(0);
  
  // Observables (existing code)
  data$ = this.http.get<any>('/api/data');
  
  // Convert observable to signal
  dataSignal = toSignal(this.data$, { initialValue: null });
  
  // Computed combining signals and converted observables
  combinedValue = computed(() => {
    const count = this.count();
    const data = this.dataSignal();
    return data ? `Count: ${count}, Data: ${data.value}` : `Count: ${count}`;
  });
  
  constructor(private http: HttpClient) {}
  
  ngOnInit() {
    // Convert signal to observable when needed
    const count$ = toObservable(this.count);
    
    count$.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(count => {
      console.log('Debounced count:', count);
    });
  }
  
  increment() {
    this.count.update(c => c + 1);
  }
}

// ✅ MIGRATION CHECKLIST

/*
PHASE 1: New Development
- ✅ Use input() for all new component inputs
- ✅ Use viewChild() for new DOM queries
- ✅ Use computed() for derived values
- ✅ Use effect() for side effects

PHASE 2: Existing Components
- ✅ Convert simple @Input to input()
- ✅ Convert @ViewChild to viewChild()
- ✅ Replace getter methods with computed()
- ✅ Convert ngOnChanges to effects

PHASE 3: Services
- ✅ Convert BehaviorSubject to signal()
- ✅ Convert derived observables to computed()
- ✅ Replace subscription management with effects
- ✅ Use toSignal() for existing observables

PHASE 4: Advanced Patterns
- ✅ Implement signal-based state management
- ✅ Convert complex reactive patterns
- ✅ Optimize performance with signals
- ✅ Remove unnecessary OnPush strategies

INTEROPERABILITY HELPERS:
- toSignal(observable) - Convert Observable to Signal
- toObservable(signal) - Convert Signal to Observable
- Signals work with async pipe
- Effects can handle async operations
*/

// ✅ TESTING SIGNALS

describe('SignalsComponent', () => {
  let component: UserCardNewComponent;
  let fixture: ComponentFixture<UserCardNewComponent>;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [UserCardNewComponent]
    });
    
    fixture = TestBed.createComponent(UserCardNewComponent);
    component = fixture.componentInstance;
  });
  
  it('should update computed when input changes', () => {
    // Set initial input
    fixture.componentRef.setInput('user', { 
      id: 1, 
      name: 'John', 
      isActive: true 
    });
    fixture.detectChanges();
    
    expect(component.userStatus()).toBe('Active');
    
    // Update input
    fixture.componentRef.setInput('user', { 
      id: 1, 
      name: 'John', 
      isActive: false 
    });
    fixture.detectChanges();
    
    expect(component.userStatus()).toBe('Inactive');
  });
});
```
**Explanation:** Migrate incrementally by starting with new components, converting inputs and queries, then services. Signals are fully interoperable with existing patterns.

**Problem:** Migrating large Angular applications to new patterns can be risky and time-consuming, requiring careful planning and execution.
**Solution:** Signals provide full interoperability with existing patterns, allowing for gradual, low-risk migration with immediate benefits.
**Benefits:**
- Incremental migration without breaking changes
- Immediate benefits from partial adoption
- Full interoperability with existing code
- Reduced migration risk and effort
- Clear migration path and strategy
**Implementation:** Start with new components using signals, gradually convert existing components, and use interoperability helpers like toSignal() and toObservable().

---## Part 5: The Future (Zoneless) - Angular Without Zone.js - The Ultimate Performance

### Slide: Part 5: The Future (Zoneless)
#### Subtitle: Angular Without Zone.js - The Ultimate Performance
The zoneless future represents Angular's evolution toward maximum performance and simplicity. By removing Zone.js dependency, Angular achieves smaller bundles, better performance, and cleaner architecture.

**Highlight:** Zoneless Angular applications rely entirely on signals for reactivity, eliminating the need for global change detection triggers and monkey patching.

**Benefits of zoneless Angular:**
- Smaller bundle size (no Zone.js dependency)
- Better performance (no monkey patching overhead)
- Cleaner debugging (no patched browser APIs)
- Better integration with other frameworks
- Simplified mental model
- Future-proof architecture

**Code Example: Zoneless Angular Configuration**
```typescript
// ✅ ZONELESS ANGULAR SETUP

// main.ts - Bootstrap zoneless application
import { bootstrapApplication } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, {
  providers: [
    // ✅ Enable zoneless change detection
    provideExperimentalZonelessChangeDetection(),
    
    // Other providers work normally
    provideRouter(routes),
    provideHttpClient(),
    // ... other providers
  ]
}).catch(err => console.error(err));

// ✅ ZONELESS COMPONENT ARCHITECTURE

@Component({
  selector: 'app-zoneless-demo',
  template: `
    <div class="zoneless-app">
      <h1>{{ title() }}</h1>
      
      <!-- Signals automatically update the DOM -->
      <p>Counter: {{ counter() }}</p>
      <p>Status: {{ status() }}</p>
      <p>Last update: {{ lastUpdate() | date:'medium' }}</p>
      
      <!-- Event handlers work normally -->
      <button (click)="increment()">Increment</button>
      <button (click)="decrement()">Decrement</button>
      <button (click)="reset()">Reset</button>
      
      <!-- Async operations with signals -->
      <div *ngIf="loading()">Loading...</div>
      <div *ngFor="let item of items(); trackBy: trackByItem">
        {{ item.name }}
      </div>
    </div>
  `
})
export class ZonelessDemoComponent {
  // ✅ Signals provide all reactivity
  title = signal('Zoneless Angular Demo');
  counter = signal(0);
  loading = signal(false);
  items = signal<Item[]>([]);
  
  // ✅ Computed signals work automatically
  status = computed(() => {
    const count = this.counter();
    if (count === 0) return 'Zero';
    return count > 0 ? 'Positive' : 'Negative';
  });
  
  lastUpdate = computed(() => {
    // Depends on counter - updates when counter changes
    this.counter();
    return new Date();
  });
  
  constructor(private http: HttpClient) {
    // ✅ Effects handle side effects
    effect(() => {
      console.log(`Counter changed to: ${this.counter()}`);
    });
    
    // Load initial data
    this.loadItems();
  }
  
  // ✅ Event handlers update signals
  increment() {
    this.counter.update(c => c + 1);
  }
  
  decrement() {
    this.counter.update(c => c - 1);
  }
  
  reset() {
    this.counter.set(0);
  }
  
  // ✅ Async operations with signals
  async loadItems() {
    this.loading.set(true);
    
    try {
      const items = await this.http.get<Item[]>('/api/items').toPromise();
      this.items.set(items || []);
    } catch (error) {
      console.error('Failed to load items:', error);
      this.items.set([]);
    } finally {
      this.loading.set(false);
    }
  }
  
  trackByItem(index: number, item: Item): number {
    return item.id;
  }
}

// ✅ COMPARISON: Zone.js vs Zoneless

// ❌ With Zone.js (traditional)
@Component({
  selector: 'app-with-zone',
  template: `
    <div>
      <p>{{ message }}</p>
      <button (click)="updateMessage()">Update</button>
    </div>
  `
})
export class WithZoneComponent {
  message = 'Hello World';
  
  updateMessage() {
    // Zone.js detects this event and triggers change detection
    setTimeout(() => {
      this.message = 'Updated!';
      // Zone.js automatically triggers change detection
    }, 1000);
  }
}

// ✅ Zoneless (signals-based)
@Component({
  selector: 'app-zoneless',
  template: `
    <div>
      <p>{{ message() }}</p>
      <button (click)="updateMessage()">Update</button>
    </div>
  `
})
export class ZonelessComponent {
  message = signal('Hello World');
  
  updateMessage() {
    // No Zone.js - signals handle reactivity
    setTimeout(() => {
      this.message.set('Updated!');
      // Signal automatically updates the DOM
    }, 1000);
  }
}

// ✅ ZONELESS BEST PRACTICES

@Component({
  selector: 'app-zoneless-best-practices',
  template: `
    <div class="best-practices">
      <!-- ✅ Use signals for all reactive state -->
      <h2>{{ pageTitle() }}</h2>
      <p>User: {{ currentUser().name }}</p>
      <p>Theme: {{ theme() }}</p>
      
      <!-- ✅ Computed values update automatically -->
      <p>Greeting: {{ greeting() }}</p>
      <p>Stats: {{ userStats() }}</p>
      
      <!-- ✅ Lists with signals -->
      <ul>
        <li *ngFor="let notification of notifications(); trackBy: trackByNotification">
          {{ notification.message }}
        </li>
      </ul>
      
      <!-- ✅ Conditional rendering -->
      <div *ngIf="hasNotifications()">
        You have {{ notifications().length }} notifications
      </div>
      
      <!-- ✅ Forms with signals -->
      <form (ngSubmit)="saveUser()">
        <input [(ngModel)]="editableUser().name" placeholder="Name">
        <input [(ngModel)]="editableUser().email" placeholder="Email">
        <button type="submit" [disabled]="!isFormValid()">Save</button>
      </form>
    </div>
  `
})
export class ZonelessBestPracticesComponent {
  // ✅ All state as signals
  pageTitle = signal('Zoneless Best Practices');
  theme = signal<'light' | 'dark'>('light');
  
  currentUser = signal({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    loginCount: 5
  });
  
  editableUser = signal({
    name: '',
    email: ''
  });
  
  notifications = signal([
    { id: 1, message: 'Welcome!', read: false },
    { id: 2, message: 'New update available', read: false }
  ]);
  
  // ✅ Computed signals for derived state
  greeting = computed(() => {
    const user = this.currentUser();
    const theme = this.theme();
    const timeOfDay = new Date().getHours() < 12 ? 'morning' : 'evening';
    
    return `Good ${timeOfDay}, ${user.name}! (${theme} theme)`;
  });
  
  userStats = computed(() => {
    const user = this.currentUser();
    return `${user.loginCount} logins`;
  });
  
  hasNotifications = computed(() => this.notifications().length > 0);
  
  isFormValid = computed(() => {
    const user = this.editableUser();
    return user.name.trim().length > 0 && user.email.includes('@');
  });
  
  constructor() {
    // ✅ Effects for side effects
    effect(() => {
      const theme = this.theme();
      document.body.className = theme;
      localStorage.setItem('theme', theme);
    });
    
    effect(() => {
      const user = this.currentUser();
      console.log(`Current user: ${user.name}`);
    });
    
    // Initialize editable user
    effect(() => {
      const user = this.currentUser();
      this.editableUser.set({
        name: user.name,
        email: user.email
      });
    });
  }
  
  saveUser() {
    const updates = this.editableUser();
    this.currentUser.update(user => ({
      ...user,
      name: updates.name,
      email: updates.email
    }));
  }
  
  toggleTheme() {
    this.theme.update(current => current === 'light' ? 'dark' : 'light');
  }
  
  trackByNotification(index: number, notification: any): number {
    return notification.id;
  }
}
```
**Explanation:** Zoneless Angular eliminates Zone.js dependency, relying entirely on signals for reactivity. This results in smaller bundles, better performance, and cleaner architecture.

**Problem:** Zone.js adds bundle size, performance overhead, and complexity through monkey patching of browser APIs.
**Solution:** Zoneless Angular removes Zone.js dependency, using signals for all reactivity needs, resulting in better performance and simpler architecture.
**Benefits:**
- Smaller bundle size (no Zone.js)
- Better performance (no monkey patching)
- Cleaner debugging experience
- Better third-party integration
- Future-proof architecture
**Implementation:** Use provideExperimentalZonelessChangeDetection() and ensure all reactive state uses signals instead of traditional change detection.

---

### Slide: Migrating to Zoneless Angular
#### Subtitle: Practical Steps for Zone.js Removal
Migrating to zoneless Angular requires careful preparation and systematic conversion of reactive patterns. Here's a comprehensive guide for successful migration.

**Zoneless migration requirements:**
- All reactive state must use signals
- No reliance on Zone.js change detection
- Manual triggering for third-party integrations
- Proper async operation handling
- Testing without Zone.js patches

**Highlight:** Zoneless migration is only successful when the entire application uses signals for reactivity and doesn't depend on Zone.js automatic change detection.

**Code Example: Complete Zoneless Migration Guide**
```typescript
// ✅ STEP 1: ENABLE ZONELESS MODE

// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';

bootstrapApplication(AppComponent, {
  providers: [
    provideExperimentalZonelessChangeDetection(),
    // Remove any Zone.js related providers
  ]
});

// ✅ STEP 2: CONVERT ALL COMPONENTS TO SIGNALS

// ❌ BEFORE: Zone.js dependent component
@Component({
  selector: 'app-old-component',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <h2>{{ user.name }}</h2>
      <p>{{ status }}</p>
      <button (click)="updateStatus()">Update</button>
    </div>
  `
})
export class OldComponent implements OnInit, OnDestroy {
  @Input() user!: User;
  
  status = '';
  private subscription = new Subscription();
  
  constructor(
    private statusService: StatusService,
    private cdr: ChangeDetectorRef
  ) {}
  
  ngOnInit() {
    this.subscription.add(
      this.statusService.getStatus().subscribe(status => {
        this.status = status;
        this.cdr.markForCheck(); // Manual change detection
      })
    );
  }
  
  updateStatus() {
    this.statusService.updateStatus().subscribe(() => {
      this.cdr.markForCheck(); // Manual change detection
    });
  }
  
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}

// ✅ AFTER: Zoneless ready component
@Component({
  selector: 'app-new-component',
  template: `
    <div>
      <h2>{{ user().name }}</h2>
      <p>{{ status() }}</p>
      <button (click)="updateStatus()">Update</button>
    </div>
  `
})
export class NewComponent {
  user = input.required<User>();
  
  // Convert to signal-based state
  private statusService = inject(StatusService);
  status = this.statusService.status; // Service exposes signal
  
  constructor() {
    // Effects replace subscriptions
    effect(() => {
      const currentUser = this.user();
      console.log(`User changed: ${currentUser.name}`);
    });
  }
  
  updateStatus() {
    this.statusService.updateStatus(); // Service handles signal updates
  }
}

// ✅ STEP 3: CONVERT SERVICES TO SIGNALS

// ❌ BEFORE: Observable-based service
@Injectable()
export class OldStatusService {
  private statusSubject = new BehaviorSubject<string>('idle');
  
  status$ = this.statusSubject.asObservable();
  
  getStatus(): Observable<string> {
    return this.http.get<string>('/api/status');
  }
  
  updateStatus(): Observable<void> {
    return this.http.post<void>('/api/status/update', {}).pipe(
      tap(() => this.statusSubject.next('updated'))
    );
  }
}

// ✅ AFTER: Signal-based service
@Injectable()
export class NewStatusService {
  private _status = signal<string>('idle');
  
  // Expose readonly signal
  status = this._status.asReadonly();
  
  constructor(private http: HttpClient) {}
  
  async getStatus(): Promise<string> {
    try {
      const status = await this.http.get<string>('/api/status').toPromise();
      this._status.set(status || 'idle');
      return status || 'idle';
    } catch (error) {
      this._status.set('error');
      throw error;
    }
  }
  
  async updateStatus(): Promise<void> {
    try {
      await this.http.post<void>('/api/status/update', {}).toPromise();
      this._status.set('updated');
    } catch (error) {
      this._status.set('error');
      throw error;
    }
  }
}

// ✅ STEP 4: HANDLE THIRD-PARTY INTEGRATIONS

@Component({
  selector: 'app-third-party-integration',
  template: `
    <div>
      <div #chartContainer></div>
      <p>Chart data points: {{ dataPoints() }}</p>
      <button (click)="updateChart()">Update Chart</button>
    </div>
  `
})
export class ThirdPartyIntegrationComponent implements AfterViewInit {
  chartContainer = viewChild<ElementRef>('chartContainer');
  dataPoints = signal<number[]>([]);
  
  private chart: any;
  
  constructor() {
    // Effect to update chart when data changes
    effect(() => {
      const data = this.dataPoints();
      if (this.chart && data.length > 0) {
        this.updateChartData(data);
      }
    });
  }
  
  ngAfterViewInit() {
    // Initialize third-party chart
    effect(() => {
      const container = this.chartContainer();
      if (container && !this.chart) {
        this.initializeChart(container.nativeElement);
      }
    });
  }
  
  private initializeChart(container: HTMLElement) {
    // Initialize chart library (e.g., Chart.js, D3)
    this.chart = new ThirdPartyChart(container, {
      onDataChange: (newData: number[]) => {
        // ✅ Manual signal update for third-party callbacks
        this.dataPoints.set(newData);
      }
    });
  }
  
  private updateChartData(data: number[]) {
    if (this.chart) {
      this.chart.updateData(data);
    }
  }
  
  updateChart() {
    const newData = Array.from({ length: 10 }, () => Math.random() * 100);
    this.dataPoints.set(newData);
  }
}

// ✅ STEP 5: HANDLE ASYNC OPERATIONS

@Component({
  selector: 'app-async-operations',
  template: `
    <div>
      <h2>Async Operations</h2>
      <p>Loading: {{ loading() }}</p>
      <p>Data: {{ data() || 'No data' }}</p>
      <p>Error: {{ error() || 'No error' }}</p>
      
      <button (click)="loadData()">Load Data</button>
      <button (click)="startPolling()">Start Polling</button>
      <button (click)="stopPolling()">Stop Polling</button>
    </div>
  `
})
export class AsyncOperationsComponent implements OnDestroy {
  loading = signal(false);
  data = signal<string | null>(null);
  error = signal<string | null>(null);
  
  private pollingInterval?: number;
  
  constructor(private http: HttpClient) {}
  
  async loadData() {
    this.loading.set(true);
    this.error.set(null);
    
    try {
      // ✅ Handle async operations manually
      const response = await this.http.get<{data: string}>('/api/data').toPromise();
      this.data.set(response?.data || null);
    } catch (err) {
      this.error.set(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      this.loading.set(false);
    }
  }
  
  startPolling() {
    this.stopPolling(); // Clear existing interval
    
    this.pollingInterval = window.setInterval(async () => {
      try {
        const response = await this.http.get<{data: string}>('/api/data').toPromise();
        this.data.set(response?.data || null);
      } catch (err) {
        console.error('Polling error:', err);
      }
    }, 5000);
  }
  
  stopPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = undefined;
    }
  }
  
  ngOnDestroy() {
    this.stopPolling();
  }
}

// ✅ STEP 6: TESTING ZONELESS COMPONENTS

describe('ZonelessComponent', () => {
  let component: NewComponent;
  let fixture: ComponentFixture<NewComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [NewComponent],
      providers: [
        // ✅ Use zoneless change detection in tests
        provideExperimentalZonelessChangeDetection()
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(NewComponent);
    component = fixture.componentInstance;
  });
  
  it('should update when signal changes', () => {
    // Set input signal
    fixture.componentRef.setInput('user', { 
      id: 1, 
      name: 'John' 
    });
    
    // ✅ Signals trigger updates automatically
    fixture.detectChanges();
    
    expect(fixture.nativeElement.textContent).toContain('John');
  });
  
  it('should handle async operations', async () => {
    const service = TestBed.inject(NewStatusService);
    
    // Mock async operation
    spyOn(service, 'getStatus').and.returnValue(Promise.resolve('active'));
    
    await service.getStatus();
    
    // ✅ Signal updates are synchronous
    expect(service.status()).toBe('active');
  });
});

// ✅ MIGRATION CHECKLIST

/*
ZONELESS MIGRATION CHECKLIST:

✅ Configuration:
- Enable provideExperimentalZonelessChangeDetection()
- Remove Zone.js imports and polyfills
- Update testing configuration

✅ Components:
- Convert all @Input to input()
- Convert all @ViewChild to viewChild()
- Replace component properties with signals
- Convert computed getters to computed()
- Replace ngOnChanges with effects
- Remove ChangeDetectionStrategy.OnPush (not needed)
- Remove ChangeDetectorRef injections

✅ Services:
- Convert BehaviorSubject to signal()
- Convert derived observables to computed()
- Replace subscription management with effects
- Handle async operations manually
- Expose readonly signals publicly

✅ Third-party Integration:
- Manual signal updates for third-party callbacks
- Use effects to react to signal changes
- Handle async operations without Zone.js

✅ Testing:
- Use zoneless change detection in tests
- Test signal updates directly
- Mock async operations properly

✅ Performance:
- Remove unnecessary OnPush strategies
- Optimize with computed signals
- Use effects for side effects only
- Monitor bundle size reduction

COMMON PITFALLS:
❌ Forgetting to update third-party integrations
❌ Leaving Zone.js dependencies in code
❌ Not handling async operations manually
❌ Missing signal updates in callbacks
❌ Incorrect test configuration
*/
```
**Explanation:** Zoneless migration requires systematic conversion of all reactive patterns to signals and proper handling of third-party integrations without Zone.js.

**Problem:** Zone.js dependency creates bundle size overhead and complexity, while migration to zoneless requires careful handling of all reactive patterns.
**Solution:** Systematic migration to signals-based reactivity enables zoneless Angular with better performance and smaller bundles.
**Benefits:**
- Significant bundle size reduction
- Better runtime performance
- Cleaner debugging experience
- Simplified architecture
- Better third-party integration
**Implementation:** Convert all components and services to use signals, handle third-party integrations manually, and test thoroughly with zoneless configuration.

---

### Slide: Zoneless Performance Benefits
#### Subtitle: Measuring the Impact of Zone.js Removal
Removing Zone.js provides measurable performance benefits in bundle size, runtime performance, and memory usage. Understanding these benefits helps justify the migration effort.

**Zoneless performance improvements:**
- Bundle size reduction: ~45KB (Zone.js + polyfills)
- Faster application startup (no API patching)
- Reduced memory overhead (no zone tracking)
- Better performance in async-heavy applications
- Improved debugging and profiling accuracy
- Better integration with performance monitoring

**Comparison: Performance Comparison:**
- **Before:** Zone.js: Larger bundles, monkey patching overhead, global change detection
- **After:** Zoneless: Smaller bundles, no patching overhead, surgical signal updates

**Code Example: Performance Measurement and Optimization**
```typescript
// ✅ PERFORMANCE MEASUREMENT TOOLS

@Injectable()
export class PerformanceMonitorService {
  private performanceMetrics = signal({
    bundleSize: 0,
    startupTime: 0,
    changeDetectionCycles: 0,
    memoryUsage: 0
  });
  
  metrics = this.performanceMetrics.asReadonly();
  
  constructor() {
    this.measureStartupPerformance();
    this.setupPerformanceObserver();
  }
  
  private measureStartupPerformance() {
    // Measure application startup time
    const navigationStart = performance.timing.navigationStart;
    const loadComplete = performance.timing.loadEventEnd;
    const startupTime = loadComplete - navigationStart;
    
    this.performanceMetrics.update(metrics => ({
      ...metrics,
      startupTime
    }));
    
    console.log(`App startup time: ${startupTime}ms`);
  }
  
  private setupPerformanceObserver() {
    // Monitor performance entries
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'measure') {
            console.log(`Performance measure: ${entry.name} - ${entry.duration}ms`);
          }
        }
      });
      
      observer.observe({ entryTypes: ['measure', 'navigation'] });
    }
  }
  
  measureChangeDetectionCycle() {
    performance.mark('cd-start');
    
    // This would be called after change detection
    setTimeout(() => {
      performance.mark('cd-end');
      performance.measure('change-detection', 'cd-start', 'cd-end');
    }, 0);
  }
  
  measureMemoryUsage() {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      this.performanceMetrics.update(metrics => ({
        ...metrics,
        memoryUsage: memory.usedJSHeapSize
      }));
    }
  }
}

// ✅ ZONELESS PERFORMANCE OPTIMIZATIONS

@Component({
  selector: 'app-performance-optimized',
  template: `
    <div class="performance-demo">
      <h2>Performance Optimized Component</h2>
      
      <!-- ✅ Efficient list rendering with signals -->
      <div class="large-list">
        <div *ngFor="let item of visibleItems(); trackBy: trackByItem" 
             class="list-item">
          {{ item.name }} - {{ item.value }}
        </div>
      </div>
      
      <!-- ✅ Computed values for expensive operations -->
      <div class="statistics">
        <p>Total Items: {{ totalItems() }}</p>
        <p>Average Value: {{ averageValue() }}</p>
        <p>Filtered Count: {{ filteredCount() }}</p>
      </div>
      
      <!-- ✅ Efficient search with debouncing -->
      <input 
        #searchInput
        (input)="updateSearch(searchInput.value)"
        placeholder="Search items..."
      >
      
      <!-- ✅ Virtual scrolling for large datasets -->
      <cdk-virtual-scroll-viewport itemSize="50" class="viewport">
        <div *cdkVirtualFor="let item of allItems(); trackBy: trackByItem">
          {{ item.name }}
        </div>
      </cdk-virtual-scroll-viewport>
    </div>
  `
})
export class PerformanceOptimizedComponent {
  // ✅ Large dataset as signal
  private allItemsSignal = signal<Item[]>([]);
  private searchTermSignal = signal('');
  private pageSignal = signal(0);
  
  // ✅ Computed for filtered and paginated data
  filteredItems = computed(() => {
    const items = this.allItemsSignal();
    const searchTerm = this.searchTermSignal().toLowerCase();
    
    if (!searchTerm) return items;
    
    return items.filter(item =>
      item.name.toLowerCase().includes(searchTerm) ||
      item.description.toLowerCase().includes(searchTerm)
    );
  });
  
  visibleItems = computed(() => {
    const filtered = this.filteredItems();
    const page = this.pageSignal();
    const pageSize = 100;
    
    return filtered.slice(page * pageSize, (page + 1) * pageSize);
  });
  
  // ✅ Expensive computations memoized with computed
  totalItems = computed(() => this.allItemsSignal().length);
  
  averageValue = computed(() => {
    const items = this.allItemsSignal();
    if (items.length === 0) return 0;
    
    const sum = items.reduce((acc, item) => acc + item.value, 0);
    return Math.round(sum / items.length * 100) / 100;
  });
  
  filteredCount = computed(() => this.filteredItems().length);
  
  // Expose readonly signals
  allItems = this.allItemsSignal.asReadonly();
  
  private searchDebounceTimer?: number;
  
  constructor(private performanceMonitor: PerformanceMonitorService) {
    // Generate large dataset
    this.generateLargeDataset();
    
    // ✅ Effect for performance monitoring
    effect(() => {
      const itemCount = this.totalItems();
      console.log(`Dataset size: ${itemCount} items`);
      this.performanceMonitor.measureMemoryUsage();
    });
  }
  
  private generateLargeDataset() {
    const items: Item[] = [];
    
    performance.mark('dataset-generation-start');
    
    for (let i = 0; i < 10000; i++) {
      items.push({
        id: i,
        name: `Item ${i}`,
        description: `Description for item ${i}`,
        value: Math.random() * 1000,
        category: `Category ${i % 10}`
      });
    }
    
    performance.mark('dataset-generation-end');
    performance.measure('dataset-generation', 'dataset-generation-start', 'dataset-generation-end');
    
    this.allItemsSignal.set(items);
  }
  
  // ✅ Debounced search update
  updateSearch(term: string) {
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    
    this.searchDebounceTimer = window.setTimeout(() => {
      performance.mark('search-start');
      this.searchTermSignal.set(term);
      performance.mark('search-end');
      performance.measure('search-filter', 'search-start', 'search-end');
    }, 300);
  }
  
  trackByItem(index: number, item: Item): number {
    return item.id;
  }
  
  // ✅ Efficient batch operations
  batchUpdateItems(updates: { id: number; value: number }[]) {
    performance.mark('batch-update-start');
    
    this.allItemsSignal.update(items =>
      items.map(item => {
        const update = updates.find(u => u.id === item.id);
        return update ? { ...item, value: update.value } : item;
      })
    );
    
    performance.mark('batch-update-end');
    performance.measure('batch-update', 'batch-update-start', 'batch-update-end');
  }
}

// ✅ PERFORMANCE COMPARISON COMPONENT

@Component({
  selector: 'app-performance-comparison',
  template: `
    <div class="comparison">
      <h2>Performance Comparison</h2>
      
      <div class="metrics">
        <div class="metric-card">
          <h3>Bundle Size</h3>
          <p class="before">With Zone.js: {{ bundleSizes.withZone }}KB</p>
          <p class="after">Zoneless: {{ bundleSizes.zoneless }}KB</p>
          <p class="savings">Savings: {{ bundleSavings() }}KB ({{ bundleSavingsPercent() }}%)</p>
        </div>
        
        <div class="metric-card">
          <h3>Startup Time</h3>
          <p class="before">With Zone.js: {{ startupTimes.withZone }}ms</p>
          <p class="after">Zoneless: {{ startupTimes.zoneless }}ms</p>
          <p class="savings">Improvement: {{ startupImprovement() }}ms ({{ startupImprovementPercent() }}%)</p>
        </div>
        
        <div class="metric-card">
          <h3>Memory Usage</h3>
          <p class="before">With Zone.js: {{ memoryUsage.withZone }}MB</p>
          <p class="after">Zoneless: {{ memoryUsage.zoneless }}MB</p>
          <p class="savings">Reduction: {{ memoryReduction() }}MB ({{ memoryReductionPercent() }}%)</p>
        </div>
      </div>
      
      <div class="performance-chart">
        <canvas #performanceChart></canvas>
      </div>
    </div>
  `
})
export class PerformanceComparisonComponent implements AfterViewInit {
  performanceChart = viewChild<ElementRef>('performanceChart');
  
  // Performance data
  bundleSizes = signal({
    withZone: 245, // KB
    zoneless: 200  // KB
  });
  
  startupTimes = signal({
    withZone: 850, // ms
    zoneless: 720  // ms
  });
  
  memoryUsage = signal({
    withZone: 12.5, // MB
    zoneless: 10.8  // MB
  });
  
  // Computed improvements
  bundleSavings = computed(() => {
    const sizes = this.bundleSizes();
    return sizes.withZone - sizes.zoneless;
  });
  
  bundleSavingsPercent = computed(() => {
    const sizes = this.bundleSizes();
    return Math.round((this.bundleSavings() / sizes.withZone) * 100);
  });
  
  startupImprovement = computed(() => {
    const times = this.startupTimes();
    return times.withZone - times.zoneless;
  });
  
  startupImprovementPercent = computed(() => {
    const times = this.startupTimes();
    return Math.round((this.startupImprovement() / times.withZone) * 100);
  });
  
  memoryReduction = computed(() => {
    const usage = this.memoryUsage();
    return Math.round((usage.withZone - usage.zoneless) * 10) / 10;
  });
  
  memoryReductionPercent = computed(() => {
    const usage = this.memoryUsage();
    return Math.round((this.memoryReduction() / usage.withZone) * 100);
  });
  
  ngAfterViewInit() {
    effect(() => {
      const canvas = this.performanceChart();
      if (canvas) {
        this.renderPerformanceChart(canvas.nativeElement);
      }
    });
  }
  
  private renderPerformanceChart(canvas: HTMLCanvasElement) {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Simple bar chart showing performance improvements
    const data = [
      { label: 'Bundle Size', withZone: this.bundleSizes().withZone, zoneless: this.bundleSizes().zoneless },
      { label: 'Startup Time', withZone: this.startupTimes().withZone, zoneless: this.startupTimes().zoneless },
      { label: 'Memory Usage', withZone: this.memoryUsage().withZone * 20, zoneless: this.memoryUsage().zoneless * 20 }
    ];
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw bars
    const barWidth = 60;
    const barSpacing = 100;
    const maxValue = Math.max(...data.flatMap(d => [d.withZone, d.zoneless]));
    
    data.forEach((item, index) => {
      const x = index * barSpacing + 50;
      
      // With Zone.js bar (red)
      const withZoneHeight = (item.withZone / maxValue) * 200;
      ctx.fillStyle = '#ff6b9d';
      ctx.fillRect(x, 250 - withZoneHeight, barWidth / 2, withZoneHeight);
      
      // Zoneless bar (green)
      const zonelessHeight = (item.zoneless / maxValue) * 200;
      ctx.fillStyle = '#06ffa5';
      ctx.fillRect(x + barWidth / 2, 250 - zonelessHeight, barWidth / 2, zonelessHeight);
      
      // Label
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px Arial';
      ctx.fillText(item.label, x, 270);
    });
  }
}
```
**Explanation:** Zoneless Angular provides significant performance benefits through reduced bundle size, faster startup, and lower memory usage, with measurable improvements in real-world applications.

**Problem:** Zone.js adds significant overhead in bundle size, runtime performance, and memory usage, especially in large or performance-critical applications.
**Solution:** Zoneless Angular eliminates Zone.js overhead, providing measurable improvements in bundle size, startup time, and runtime performance.
**Benefits:**
- ~45KB bundle size reduction
- 15-20% faster startup times
- 10-15% memory usage reduction
- Better performance profiling accuracy
- Improved third-party integration
**Implementation:** Measure performance before and after zoneless migration, optimize with signals and computed values, and monitor improvements with performance tools.

---

### Slide: Zoneless Ecosystem and Future
#### Subtitle: The Road Ahead for Angular
The zoneless future represents Angular's evolution toward a more performant, simpler, and more interoperable framework. Understanding the ecosystem implications helps prepare for the future.

**Zoneless ecosystem benefits:**
- Better integration with other frameworks and libraries
- Simplified server-side rendering (SSR)
- Improved web worker compatibility
- Better performance monitoring and profiling
- Reduced complexity for new developers
- Future-proof architecture aligned with web standards

**Highlight:** Zoneless Angular represents the future direction of the framework, with signals becoming the primary reactivity mechanism and Zone.js eventually being phased out.

**Code Example: Future Angular Architecture with Signals**
```typescript
// ✅ FUTURE ANGULAR COMPONENT ARCHITECTURE

// The future of Angular components - fully signal-based
@Component({
  selector: 'app-future-component',
  // No changeDetection needed - signals handle everything
  template: `
    <div class="future-component">
      <!-- Signal inputs work seamlessly -->
      <h1>{{ title() }}</h1>
      <p>Welcome, {{ user().name }}!</p>
      
      <!-- Two-way binding with signals -->
      <input [(ngModel)]="searchTerm" placeholder="Search...">
      
      <!-- Computed values update automatically -->
      <div class="results">
        <p>Found {{ filteredResults().length }} results</p>
        <div *ngFor="let result of filteredResults(); trackBy: trackByResult">
          {{ result.title }}
        </div>
      </div>
      
      <!-- Async operations with signals -->
      <div *ngIf="loading()">Loading...</div>
      <div *ngIf="error() as err" class="error">{{ err }}</div>
      
      <!-- Event handling -->
      <button (click)="refresh()">Refresh</button>
      <button (click)="exportData()">Export</button>
    </div>
  `
})
export class FutureComponent {
  // Signal inputs - the new standard
  title = input<string>('Future Angular');
  user = input.required<User>();
  
  // Two-way binding signal
  searchTerm = model<string>('');
  
  // State signals
  private _results = signal<SearchResult[]>([]);
  private _loading = signal(false);
  private _error = signal<string | null>(null);
  
  // Computed signals for derived state
  filteredResults = computed(() => {
    const results = this._results();
    const term = this.searchTerm().toLowerCase();
    
    if (!term) return results;
    
    return results.filter(result =>
      result.title.toLowerCase().includes(term) ||
      result.description.toLowerCase().includes(term)
    );
  });
  
  // Expose readonly signals
  results = this._results.asReadonly();
  loading = this._loading.asReadonly();
  error = this._error.asReadonly();
  
  constructor(private dataService: DataService) {
    // Effects replace lifecycle hooks for reactive operations
    effect(() => {
      const user = this.user();
      console.log(`User changed: ${user.name}`);
      this.loadUserData(user.id);
    });
    
    // Debounced search effect
    effect(() => {
      const term = this.searchTerm();
      if (term.length > 2) {
        this.performSearch(term);
      }
    });
  }
  
  private async loadUserData(userId: number) {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const results = await this.dataService.getUserData(userId);
      this._results.set(results);
    } catch (error) {
      this._error.set(error instanceof Error ? error.message : 'Unknown error');
    } finally {
      this._loading.set(false);
    }
  }
  
  private async performSearch(term: string) {
    try {
      const results = await this.dataService.search(term);
      this._results.set(results);
    } catch (error) {
      console.error('Search failed:', error);
    }
  }
  
  refresh() {
    this.loadUserData(this.user().id);
  }
  
  async exportData() {
    const data = this.filteredResults();
    // Export logic
  }
  
  trackByResult(index: number, result: SearchResult): number {
    return result.id;
  }
}

// ✅ FUTURE SERVICE ARCHITECTURE

@Injectable({
  providedIn: 'root'
})
export class FutureDataService {
  // Private signals for internal state
  private _cache = signal(new Map<string, any>());
  private _requestsInFlight = signal(new Set<string>());
  
  // Public computed signals
  cacheSize = computed(() => this._cache().size);
  activeRequests = computed(() => this._requestsInFlight().size);
  
  constructor(private http: HttpClient) {
    // Effect for cache management
    effect(() => {
      const cache = this._cache();
      if (cache.size > 100) {
        // Implement LRU cache cleanup
        this.cleanupCache();
      }
    });
  }
  
  // Reactive data fetching with caching
  async getData(key: string): Promise<any> {
    const cache = this._cache();
    
    // Return cached data if available
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    // Prevent duplicate requests
    const inFlight = this._requestsInFlight();
    if (inFlight.has(key)) {
      return this.waitForRequest(key);
    }
    
    // Mark request as in flight
    this._requestsInFlight.update(set => new Set([...set, key]));
    
    try {
      const data = await this.http.get(`/api/data/${key}`).toPromise();
      
      // Update cache
      this._cache.update(cache => new Map([...cache, [key, data]]));
      
      return data;
    } finally {
      // Remove from in-flight requests
      this._requestsInFlight.update(set => {
        const newSet = new Set(set);
        newSet.delete(key);
        return newSet;
      });
    }
  }
  
  private async waitForRequest(key: string): Promise<any> {
    // Wait for in-flight request to complete
    while (this._requestsInFlight().has(key)) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    return this._cache().get(key);
  }
  
  private cleanupCache() {
    // Implement LRU cache cleanup logic
    const cache = this._cache();
    const entries = Array.from(cache.entries());
    const toKeep = entries.slice(-50); // Keep last 50 entries
    
    this._cache.set(new Map(toKeep));
  }
}

// ✅ FUTURE APPLICATION ARCHITECTURE

// main.ts - Future Angular bootstrap
import { bootstrapApplication } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';

bootstrapApplication(AppComponent, {
  providers: [
    // Zoneless is the default in future Angular
    provideExperimentalZonelessChangeDetection(),
    
    // Enhanced providers for signals ecosystem
    provideSignalsRouter(), // Future signals-based router
    provideSignalsHttpClient(), // Future signals-based HTTP
    provideSignalsAnimations(), // Future signals-based animations
    
    // State management with signals
    provideSignalsStore(), // Future built-in state management
  ]
});

// ✅ FUTURE FRAMEWORK FEATURES

// Future Angular Router with signals
@Injectable()
export class FutureRouterService {
  // Router state as signals
  currentRoute = signal<Route | null>(null);
  params = signal<Record<string, string>>({});
  queryParams = signal<Record<string, string>>({});
  
  // Computed navigation state
  isNavigating = signal(false);
  canGoBack = computed(() => window.history.length > 1);
  
  // Navigation methods
  navigate(path: string, params?: Record<string, any>) {
    this.isNavigating.set(true);
    // Navigation logic
    this.isNavigating.set(false);
  }
  
  // Reactive route guards
  canActivate(route: Route): boolean {
    // Use signals for reactive route guards
    return this.checkPermissions(route);
  }
  
  private checkPermissions(route: Route): boolean {
    // Permission checking logic
    return true;
  }
}

// Future HTTP Client with signals
@Injectable()
export class FutureHttpService {
  // Request state signals
  private _pendingRequests = signal(0);
  private _requestHistory = signal<RequestLog[]>([]);
  
  // Public signals
  isLoading = computed(() => this._pendingRequests() > 0);
  requestCount = computed(() => this._requestHistory().length);
  
  async get<T>(url: string): Promise<T> {
    this._pendingRequests.update(count => count + 1);
    
    try {
      const response = await fetch(url);
      const data = await response.json();
      
      // Log request
      this._requestHistory.update(history => [
        ...history,
        { url, method: 'GET', timestamp: new Date(), success: true }
      ]);
      
      return data;
    } catch (error) {
      this._requestHistory.update(history => [
        ...history,
        { url, method: 'GET', timestamp: new Date(), success: false }
      ]);
      throw error;
    } finally {
      this._pendingRequests.update(count => count - 1);
    }
  }
}

// ✅ FUTURE DEVELOPMENT EXPERIENCE

// Enhanced developer tools for signals
@Injectable()
export class SignalsDevToolsService {
  private _signalRegistry = signal(new Map<string, any>());
  private _signalUpdates = signal<SignalUpdate[]>([]);
  
  // Register signal for debugging
  registerSignal(name: string, signal: any) {
    this._signalRegistry.update(registry => 
      new Map([...registry, [name, signal]])
    );
  }
  
  // Track signal updates
  trackUpdate(signalName: string, oldValue: any, newValue: any) {
    this._signalUpdates.update(updates => [
      ...updates,
      {
        signalName,
        oldValue,
        newValue,
        timestamp: new Date()
      }
    ]);
  }
  
  // Get signal dependency graph
  getDependencyGraph(): SignalDependency[] {
    // Build dependency graph for visualization
    return [];
  }
  
  // Performance profiling
  profileSignalUpdates(): SignalProfile[] {
    // Profile signal update performance
    return [];
  }
}

// Future Angular will have built-in signals devtools
declare global {
  interface Window {
    ngSignals: {
      inspect: (signal: any) => SignalInspection;
      profile: () => SignalProfile[];
      dependencies: (signal: any) => any[];
    };
  }
}
```
**Explanation:** The future of Angular is signals-first, zoneless, and built around reactive primitives that provide better performance, simpler mental models, and enhanced developer experience.

**Problem:** Current Angular complexity with Zone.js, mixed reactivity models, and performance overhead limits scalability and developer experience.
**Solution:** Future Angular with signals-first architecture, zoneless operation, and unified reactivity provides a simpler, more performant, and more maintainable framework.
**Benefits:**
- Unified reactivity model with signals
- Better performance and smaller bundles
- Simplified mental model for developers
- Enhanced debugging and profiling
- Better ecosystem integration
- Future-proof architecture
**Implementation:** Adopt signals now, prepare for zoneless migration, and align with Angular's future direction for long-term maintainability and performance.

---